1.Http 和 TCP 区别:
	1>RPC并没有规定数据传输格式，这个格式可以任意指定，不同的RPC协议，数据格式不一定相同。
	2>Http中还定义了资源定位的路径，RPC中并不需要
	3>最重要的一点：RPC需要满足像调用本地服务一样调用远程服务，也就是对调用过程在API层面进行封装。Http协议没有这样的要求，因此请求、响应等细节需要我们自己去实现。
	优点：RPC方式更加透明，对用户更方便。Http方式更灵活，没有规定API和语言，跨语言、跨平台
	缺点：RPC方式需要在API层面进行封装，限制了开发的语言环境
2.equals比较步骤:
	equals方法，内部实现分为三个步骤：
		1>先 比较引用是否相同(是否为同一对象),
		2>再 判断类型是否一致（是否为同一类型）,
		3>最后 比较内容是否一致
3.equals 重写原则:
	1>对称性	2>自反性	3>传递性	4>一致性
4.HashMap原理:
	1>hashing概念:
		根据一定的算法对键(key)进行hash运算,生成一个int值,相当于对一个数据进行摘要运算.
	2>解决碰撞:
		当两个键的hash值相同时,调用equals方法进行比较,相同将旧的键值对抛弃,不同则将新的键值对存储于*链表中;
	3>get和put:
		#1 get时首先根据key值的hashcode查找元素,如果第一个元素的key值不对,则调用其next方法继续寻找下一个元素;
		#2 put时根据key值hashcode决定存放位置(bucket),如果该位置已有其他元素,则按照碰撞原则进行存放;
	4>key值不可变对象:
		以为要根据key值的hashcode来计算元素存放位置,所以key值应当为不可变对象;
	5>多线程竞争:
		当HashMap的负载因子超过0.75(即大小超过了75%),则会重新调整大小,大小便为原来的2倍,
		如果两个线程同时对map进行扩容,则会出现多线程竞争,造成死锁
	深入HashMap:
	1>HashMap初始长度:
		#1 HashMap初始长度为16,扩容时也是2倍扩充,即大小总为2的指数
		#2 hash值的计算:  
			简单的方法是用key值的hashcode对map长度进行取模运算,但效率太低;
			HashMap使用key的hashcode[HashCode(key)]和 Map长度-1[map.length-1]进行 *与* 位运算(先将两者转为2进制,结果再转为 十进制);
		#3 长度为何为2的指数:
			当map长度为2指数时,length-1 的二进制总为 1111...1,当 与 运算时,index值总是取决于hashcode最后几位;
			这样做实现了Hash算法的 *均匀分布*原则
5.参数传递:
	1>对于基本数据类型,eg: a=1 func(int a){a=2}; 
		方法内对于形参的修改不会影响原来的值
	2>对于引用类型的数据(对象),eg: p=new Person();func(Person p){//p=new Person();}
		(1)方法内形参引用指向新的对象时,改变形参对象不会影响外部实参对象;
		(2)方法内形参引用并未指向新的对象,即实参和形参指向同一个对象的地址,则改变形参对象也会改变外部实参对象;
	# tips:
		Java 参数传递都是值传递,不存在引用传递
6.重写和重载:
	#重载:
		1> 方法名相同,参数类型,顺序,个数不同
		2> 与返回值无关,不能单纯修改返回值来重载方法
		3> 存在于父类和子类,同类中
		4> 可以抛出不同的异常,有不同的修饰符
	#重写:
		1> 方法名相同,参数列表相同,返回值类型相同(只有内部逻辑不同);
		2> 存在于父子类中;
		3> 子类的访问权限大于等于父类;
		4> 构造方法不能被重写,声明为 static,final 的方法不能被重写,但 static 可以被重新声明
		5> 子类不能抛出比父类更广泛的运行时异常
7.抽象类和接口:
	# 抽象类:
		1>抽象类可以有构造方法和成员变量;
		2>抽象类可以有抽象方法和具体方法;
		2>抽象类可以有静态方法;
		3>子类继承抽象类必须实现其中的抽象方法,否则也需要声明为抽象方法
		4>抽象类的方法可以用任意修饰符
		# tips:
			抽象方法不能被 static(静态方法无法被重写),native(java本地方法,使用C另外实现),synchronized(同步需要实现细节,而抽象不涉及细节) 修饰
	# 接口:
		1>接口只能有抽象方法,不能有构造方法;
		2>接口默认的修饰符是public,定义的成员变量其实是 常量
		3>接口中不能有静态方法;
	#相同:
		1>可以将接口和抽象类当做引用类型;
		2>两者均不能被实例化:
		3>继承抽象类或者实现接口的类都必须实现其中的抽象方法;
8.静态变量和实例变量:
	1>静态变量被 static 修饰,也叫类变量,不属于任何一个实例,在内存中只有一个,多个实例共享;
	2>实例变量 属于类的一个实例,需要先实例化一个类
9.对String直接操作等于新建String对象,频繁对String操作使用 StringBuilder 
	Tips: 
		1>StringBuffer 也可对String进行操作,是线程安全的,而StringBuilder非线程安全,但速度快
		2>String 用 "+" 连接时其实也是调用StringBuilder操作,对String使用简单的"+"操作,效率与Builder差不多
		但对String频繁操作,比如将"+"操作放在循环体中,则底层会创建很多的StringBuilder对象,效率低并造成内存浪费;
		所以,使用StringBuilder对象至于循环之外,且不与"+"混用(混用也会创建不同的StringBuilder对象)
10.Java异常分类:
	1>按照处理时机分为 编译时异常(也叫强制性异常或者checked异常),运行时异常 RuntimeException.
	2>checked异常必须被显式的处理,使用 try...catch 或在方法上声明抛出;
	3>运行时异常则由异常处理类(可自定义)来处理
11.数据类型及大小:
				字节    bit
	1> byte  	 1 		8;
	2> short 	 2		16;
	3> int		 4		32;
	4> long      8		64;
	5> float     4      32;
	6> double    8		64;
	7> char      2		16;
	8> boolean	 1		8;
	#Tips:
	String 是引用类型,底层用char数组实现
12.String常量及引用相加:
	String str="abc";
	String str1,str2="a","bc";
	String str3="a"+"bc";
	String str4=str1+str2;
	str==str3;//True
	str==str4;//False
	str==
	# Tips:
		1>String 常量相加是在栈中常量池进行操作;
		  而 引用相加 则是两个String对象进行相加,在堆中进行;
		  两者会产生不同的对象
		2>String 
13.String.intern():
	1> String.intern()返回String在常量池中对象的引用,如果常量池没有则将当前String添加进常量池;
	2> intern 就是为了减少内存消耗
	3> JDK 1.7+版本:
		eg:
		String s1=new String("1")+new String("1");
		s1.intern();
		s2="11";
		s1==s2; //true
		//s1==s2; //false jdk 1.6--版本
		JDK 1.7 常量池被放入了堆中进行操作,故s1在经过intern之后(指向堆中常量池"11"),和s2指向是一个对象
14.Java 8日期时间特性:
	1> 不变性(安全性),所有时间日期类不可变,适应多线程环境;
	2> 关注点分离: 人可读时间和 unixtamstap 机器时间分离;
	3> 清晰: 所有类中方法都被明确定义.都实现了format和parse方法;
	4> 实用性: 所有新的日期/时间 Api都实现了一系列通用方法用以完成常用操作,如日期/时间加减
	5> 扩展性: 基于Iso-8601标准,但也可以应用于非ISo日历;
15.short&&int:
	short s=1; s=s+1; //编译失败
			   s+=1;  //编译成功
	1> s+1 时,1 属于 int 类型,相加后结果为int类型;
	2> s+=1,相当于s=(short)(s+1),自动进行了数据类型转换;
16.Integer的创建:
	1> 创建Integer对象时,如果传入的 int 值在 -128~127 时,则将该对象加入常量池,后续该值的integer对象指向同一个对象;
	2> 超出-128~127 范围的,则每次都会新建integer对象,即使两个对象的值相同.
17.Java接口的继承:
	1>接口可以被继承;
	2>继承者也是接口,且可以重载override父接口(P_Interface)中抽象方法,重载后该方法在子接口(C_Interface)中可变为具体方法;
	3>当实现类(G_Class) implements 实现子接口(C_Interface),重载方法时可以显式的调用子接口中的实现,Eg:
		@override
		public void hello(){
			//可以实现多个接口,显式调用接口实现方法
			//也可在实现类中自己实现
			C_Interface_1.super.hello();
			C_Interface_2.super.hello();
		}
18.Java对象的克隆Clone:
	两种方式
	1> 实现Cloneable接口并重写Object类中的 clone 方法;
	2> 实现Serializable,利用序列化和反序列化来克隆,这样得到的对象相当于深拷贝;
19.Java序列化Serializable:
	#序列化特点:
		1> 父类可以被序列化则子类也可以被序列化
		2> static 静态变量和transient(临时数据)不能被序列化:
			静态变量或常量属于类而不属于某个对象,序列化是针对对象的操作;
		3> 如果父类没有实现 Serializable 接口,那么反序列化子类时会调用父类的 空构造 方法,如果父类没有该方法则会报错
			如果父类实现了Serializable,则反序列化子类时不会调用父类空构造
	#Java序列化过程
		1> 使用 ObjectOutputStream.rwiteObject() 将对象写入文件流或者字节流中;
		2> 使用 ObjectInputStream.readObject(),从文件流或字节流等流中反序列化出来;
20.HashMap,HashTable,HashSet:
	1>HashMap实现参照之前;
	2>HashTable:
		(1)HashTable基于Dictionary类,而HashMap实现了Map接口;
		(2)HashTable不允许 null 作为键或者值,而HashMap允许一个 null 键和多个 null 值;
		(3)HashTable线程安全,HashMap不安全;
		(4)HashTable的hash值直接使用,而HashMap计算完hashCode之后会进行其他计算(与Map长度值-1 做与运算);
		(5)HashTable初始11,扩充时2*old+1,HashMap初始16,扩充时2*old;
	3>HashSet底层使用HashMap实现,元素值都存在于HashMap key中,value为一个常量对象(new Object()),非线程安全;
	#Tips:
		1>Vector也是线程安全的;
		2>线程安全的集合类型无非就是在核心方法上增加 synchronized 关键字;
		3>Collections工具类提供的API可以让不安全的集合变为线程安全的,Eg:
			Collections.synchronizedCollection(c);
			Collections.synchronizedList(l);
			...
21.ArrayList内部实现:
	1> ArrayList内部维护一个 Object[] 数组;
	2> 当List需要扩容时:
		(1) 当前长度小于6,则一次性分配12个长度;
		(2) 当前长度大于6,则一次性增加当前长度的 1/2(new_size=size+size>>>1,移位运算比 /2 数学计算快).
22.ConcurrentHashMap:
	1>JDK 1.8之前,通过HashEntry和Segment数组实现,一个Map由n个Segment数组组成,一个Segment包含n个HashEntry键值对
	2>内部采用分段锁机制,最大支持16个线程并发,访问不同的table块

23.数组和链表:
	1> 数组在内存中需要一段连续的空间,且创建时需要指定大小,空间利用率不高,不利于扩展,查询快速,修改缓慢;
	2> 链表不需要连续的内存空间,动态扩展大小,适合频繁的插入,删除操作
24.Static代码块执行时机:
	1>调用静态变量或静态方法时(注:当静态变量被 final 修饰即常量时,不会调用static代码块);
	2>类初始化时,static 代码块先于初始化方法执行;
25.ThreadLocal:
	线程局部变量 ，是 Java中一种较为特殊的线程绑定机制，可以为每一个使用该变量的线程都提供一个变量值的副本，
	并且每一个线程都可以独立地改变自己的副本，而不会与其它线程的副本发生冲突.
26.Runnable和Callable的区别:
	1>Runnable 规定的方法是run(),Callable规定的方法是call();
	2>run方法没有返回值,call方法可以有返回值;
	3>call方法可以抛出异常,run方法不能抛出异常;
	4>运行Callable任务可以获得一个 Future对象,表示异步计算的结果,可以获取任务结果,状态,对任务进行终止;
27.ExecutorService/Executors:
	1>ExecutorService pool=Executors.newFixedThreadPool(3);
		通过线程池工厂类 Executors 可创建 固定大小线程池,可变连接池,单一连接池,延迟连接池
	2>固定大小连接池: 无论添加多少个任务,始终起指定的N各线程去执行任务
	  其他类型连接池根据名称即可推断特点;
	3>连接池的执行方式:
		execute(Runnable):无法得知 Runnable对象的执行结果
		submit(Runnable/Callable): 返回一个Future对象,通过future对象可以得知任务的执行状态,如果执行的是Callable对象,则Future对象还可以获取执行Callable执行后的返回值;
		invokeAny(Set<Callable>/List<Callable>): 接收一个Callable对象的集合,只要集合中任何一个任务结束(正常结束或者抛出异常),则其他Callable任务讲被终止,所以返回的是单一结果;
		invokeAll(et<Callable>/List<Callable>): 接收一个Callable对象的集合,返回一个Future对象的集合,标识所有任务的结果,会执行完所有任务(但是无法得知单一任务是正常结束还是异常);
	4>连接池的终止方式:
		shutdown: 终止空闲的线程,已经提交任务的无法终止;
		shutdownNow:interrupt所有线程,因此大部分线程将被终止.
28.ForkJoinPool:
	1>合并和分叉线程池;
	2>允许执行RecursiveAction(无返回值)和RecursiveTask(有返回值);
	3>自定义任务类可以继承 RecursiveAction 或 RecursiveTask;
	4>任务可以进一步被拆分成若干个子任务;
	5>ForkJoinPool.invoke(RecursiveAction/RecursiveTask),获取结果.
29.Java并发队列:
	#阻塞队列 BlockingQueue(使用锁实现)
		1>公平锁:在并发环境中,每个线程在获取锁时会先查看此锁维护的等待队列,如果为空或者当前线程排第一,则该线程获得锁
			非公平锁:每个线程上来就尝试获得锁,如果获取失败则再采用公平锁的机制获取锁
		2>
	#非阻塞队列(使用CAS算法实现)
	
30.Java线程池排队和并发策略:
	1>线程池参数解读:
		ThreadPoolExecutor(int corePoolSize,
		  int maximumPoolSize,
		  long keepAliveTime,
		  TimeUnit unit,
		  BlockingQueue<Runnable> workQueue,
		  ThreadFactory threadFactory,
		  RejectedExecutionHandler handler)
		(1)corePoolSize:核心线程数(池中保留线程数),包括空闲线程.线程池初始化并不会立即创建新线程,直到有任务提交,才新建线程使线程数量逐渐达到corePoolSize;
		(2)maximumPoolSize:最大线程数.当核心线程数满,并且阻塞队列也满时,才会判断当前线程数是否小于最大线程数,从而决定是否新建线程;
		(3)keepAliveTime:空闲线程的存活时间,当超过设定时间后,大于核心线程数的空闲线程会被终止(也可通过其他参数设置核心线程中的空闲线程也被终止);
		(4)unit:keepAliveTime 的时间单位;
		(5)workQueue:当线程数量大于等于核心线程数时,用于存储任务的队列,包括有界,无界队列,优先级队列等;
		(6)threadFactory:执行程序创建新线程时的工厂
		(7)handler:当最大线程数和阻塞队列都满时,线程的抛弃策略(详细见之后)
	2>线程池阻塞队列:
		(1)无界队列 LinkedBlockingQueue:
			newSingleThreadExecutor 和 newFixedThreadPool 都使用无界队列
			##当无界队列不设定大小时,池中创建的线程不会超过 corePoolSize,此时 maximumPoolSize(最大线程数)也就没有限制意义,多余的任务会缓存进无界队列;
			##只有当无界队列设定了大小时,如果任务数量超过最大线程数和队列大小之和时,才会用到拒绝策略
			#Tips: 使用无界队列时,队列大小没有限制,任务过多时可能会造成 OOM;
		(2)有界队列:
			ArrayBlockingQueue:
			PriorityBlockingQueue: 任务优先级排序需要任务的Comparator来决定
			#有界队列能有效防止资源耗尽,但可能比较难控制,需要队列大小和线程池大小配合使用
		(3)直接提交(同步移交队列):
			SynchronousQueue:并不是一个真正的队列,而是一种移交机制.类似于生产者-消费者模式,一端将任务放入队列,一端(线程池)取出任务;
			#直接提交,线程池不会对任务进行缓存,每当有新任务时,会直接创建新线程来执行任务,需要线程池有无限容量
		(4)延时队列:
			DelayedWorkQueue:是 ScheduledThreadPoolExecutor 的静态内部类,定时线程池使用DelayedWorkQueue来创建线程
			#执行线程时可指定延迟时间
	3>线程池拒绝策略:
		(1)饱和策略:AbortPolicy
			当任务数量大于线程池最大线程数和阻塞队列容量时,丢弃新添加的任务并抛出异常 RejectedExecutionException
			#这种情况需要线程池有限制数量,而阻塞队列需要时有界队列或限制大小的无界队列.
		(2)丢弃策略 DiscardPolicy:
			当任务数量大于最大线程数和队列容量时,新增加的任务将被丢去,但不会抛出异常
		(3)丢弃任务策略 DiscardOldestPolicy:
			当任务数量大于最大线程数和队列容量时,丢弃缓存在队列中的头部元素即最先加入队列的元素
		(4)调用者运行策略 CallerRunsPolicy:
			当线程池饱和之后,新添加的任务将退回给调用线程池的主线程直接运行,主线程运行任务期间无法再提交新的任务
