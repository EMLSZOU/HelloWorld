1.Http 和 TCP 区别:
	1>RPC并没有规定数据传输格式，这个格式可以任意指定，不同的RPC协议，数据格式不一定相同。
	2>Http中还定义了资源定位的路径，RPC中并不需要
	3>最重要的一点：RPC需要满足像调用本地服务一样调用远程服务，也就是对调用过程在API层面进行封装。Http协议没有这样的要求，因此请求、响应等细节需要我们自己去实现。
	优点：RPC方式更加透明，对用户更方便。Http方式更灵活，没有规定API和语言，跨语言、跨平台
	缺点：RPC方式需要在API层面进行封装，限制了开发的语言环境
2.equals比较步骤:
	equals方法，内部实现分为三个步骤：
		1>先 比较引用是否相同(是否为同一对象),
		2>再 判断类型是否一致（是否为同一类型）,
		3>最后 比较内容是否一致
3.equals 重写原则:
	1>对称性	2>自反性	3>传递性	4>一致性
4.HashMap原理:
	1>hashing概念:
		根据一定的算法对键(key)进行hash运算,生成一个int值,相当于对一个数据进行摘要运算.
	2>解决碰撞:
		当两个键的hash值相同时,调用equals方法进行比较,相同将旧的键值对抛弃,不同则将新的键值对存储于*链表中;
	3>get和put:
		#1 get时首先根据key值的hashcode查找元素,如果第一个元素的key值不对,则调用其next方法继续寻找下一个元素;
		#2 put时根据key值hashcode决定存放位置(bucket),如果该位置已有其他元素,则按照碰撞原则进行存放;
	4>key值不可变对象:
		以为要根据key值的hashcode来计算元素存放位置,所以key值应当为不可变对象;
	5>多线程竞争:
		当HashMap的负载因子超过0.75(即大小超过了75%),则会重新调整大小,大小便为原来的2倍,
		如果两个线程同时对map进行扩容,则会出现多线程竞争,造成死锁
	深入HashMap:
	1>HashMap初始长度:
		#1 HashMap初始长度为16,扩容时也是2倍扩充,即大小总为2的指数
		#2 hash值的计算:  
			简单的方法是用key值的hashcode对map长度进行取模运算,但效率太低;
			HashMap使用key的hashcode[HashCode(key)]和 Map长度-1[map.length-1]进行 *与* 位运算(先将两者转为2进制,结果再转为 十进制);
		#3 长度为何为2的指数:
			当map长度为2指数时,length-1 的二进制总为 1111...1,当 与 运算时,index值总是取决于hashcode最后几位;
			这样做实现了Hash算法的 *均匀分布*原则
5.参数传递:
	1>对于基本数据类型,eg: a=1 func(int a){a=2}; 
		方法内对于形参的修改不会影响原来的值
	2>对于引用类型的数据(对象),eg: p=new Person();func(Person p){//p=new Person();}
		(1)方法内形参引用指向新的对象时,改变形参对象不会影响外部实参对象;
		(2)方法内形参引用并未指向新的对象,即实参和形参指向同一个对象的地址,则改变形参对象也会改变外部实参对象;
	# tips:
		Java 参数传递都是值传递,不存在引用传递
6.重写和重载:
	#重载:
		1> 方法名相同,参数类型,顺序,个数不同
		2> 与返回值无关,不能单纯修改返回值来重载方法
		3> 存在于父类和子类,同类中
		4> 可以抛出不同的异常,有不同的修饰符
	#重写:
		1> 方法名相同,参数列表相同,返回值类型相同(只有内部逻辑不同);
		2> 存在于父子类中;
		3> 子类的访问权限大于等于父类;
		4> 构造方法不能被重写,声明为 static,final 的方法不能被重写,但 static 可以被重新声明
		5> 子类不能抛出比父类更广泛的运行时异常
7.抽象类和接口:
	# 抽象类:
		1>抽象类可以有构造方法和成员变量;
		2>抽象类可以有抽象方法和具体方法;
		2>抽象类可以有静态方法;
		3>子类继承抽象类必须实现其中的抽象方法,否则也需要声明为抽象方法
		4>抽象类的方法可以用任意修饰符
		# tips:
			抽象方法不能被 static(静态方法无法被重写),native(java本地方法,使用C另外实现),synchronized(同步需要实现细节,而抽象不涉及细节) 修饰
	# 接口:
		1>接口只能有抽象方法,不能有构造方法;
		2>接口默认的修饰符是public,定义的成员变量其实是 常量
		3>接口中不能有静态方法;
	#相同:
		1>可以将接口和抽象类当做引用类型;
		2>两者均不能被实例化:
		3>继承抽象类或者实现接口的类都必须实现其中的抽象方法;
8.静态变量和实例变量:
	1>静态变量被 static 修饰,也叫类变量,不属于任何一个实例,在内存中只有一个,多个实例共享;
	2>实例变量 属于类的一个实例,需要先实例化一个类
9.对String直接操作等于新建String对象,频繁对String操作使用 StringBuilder 
	Tips: 
		1>StringBuffer 也可对String进行操作,是线程安全的,而StringBuilder非线程安全,但速度快
		2>String 用 "+" 连接时其实也是调用StringBuilder操作,对String使用简单的"+"操作,效率与Builder差不多
		但对String频繁操作,比如将"+"操作放在循环体中,则底层会创建很多的StringBuilder对象,效率低并造成内存浪费;
		所以,使用StringBuilder对象至于循环之外,且不与"+"混用(混用也会创建不同的StringBuilder对象)
10.Java异常分类:
	1>按照处理时机分为 编译时异常(也叫强制性异常或者checked异常),运行时异常 RuntimeException.
	2>checked异常必须被显式的处理,使用 try...catch 或在方法上声明抛出;
	3>运行时异常则由异常处理类(可自定义)来处理
11.数据类型及大小:
				字节    bit
	1> byte  	 1 		8;
	2> short 	 2		16;
	3> int		 4		32;
	4> long      8		64;
	5> float     4      32;
	6> double    8		64;
	7> char      2		16;
	8> boolean	 1		8;
	#Tips:
	String 是引用类型,底层用char数组实现
12.String常量及引用相加:
	String str="abc";
	String str1,str2="a","bc";
	String str3="a"+"bc";
	String str4=str1+str2;
	str==str3;//True
	str==str4;//False
	str==
	# Tips:
		1>String 常量相加是在栈中常量池进行操作;
		  而 引用相加 则是两个String对象进行相加,在堆中进行;
		  两者会产生不同的对象
		2>String 
13.String.intern():
	1> String.intern()返回String在常量池中对象的引用,如果常量池没有则将当前String添加进常量池;
	2> intern 就是为了减少内存消耗
	3> JDK 1.7+版本:
		eg:
		String s1=new String("1")+new String("1");
		s1.intern();
		s2="11";
		s1==s2; //true
		//s1==s2; //false jdk 1.6--版本
		JDK 1.7 常量池被放入了堆中进行操作,故s1在经过intern之后(指向堆中常量池"11"),和s2指向是一个对象
14.Java 8日期时间特性:
	1> 不变性(安全性),所有时间日期类不可变,适应多线程环境;
	2> 关注点分离: 人可读时间和 unixtamstap 机器时间分离;
	3> 清晰: 所有类中方法都被明确定义.都实现了format和parse方法;
	4> 实用性: 所有新的日期/时间 Api都实现了一系列通用方法用以完成常用操作,如日期/时间加减
	5> 扩展性: 基于Iso-8601标准,但也可以应用于非ISo日历;
15.short&&int:
	short s=1; s=s+1; //编译失败
			   s+=1;  //编译成功
	1> s+1 时,1 属于 int 类型,相加后结果为int类型;
	2> s+=1,相当于s=(short)(s+1),自动进行了数据类型转换;
