1.Http 和 TCP 区别:
	1>RPC并没有规定数据传输格式，这个格式可以任意指定，不同的RPC协议，数据格式不一定相同。
	2>Http中还定义了资源定位的路径，RPC中并不需要
	3>最重要的一点：RPC需要满足像调用本地服务一样调用远程服务，也就是对调用过程在API层面进行封装。Http协议没有这样的要求，因此请求、响应等细节需要我们自己去实现。
	优点：RPC方式更加透明，对用户更方便。Http方式更灵活，没有规定API和语言，跨语言、跨平台
	缺点：RPC方式需要在API层面进行封装，限制了开发的语言环境
2.equals比较步骤:
	equals方法，内部实现分为三个步骤：
		1>先 比较引用是否相同(是否为同一对象),
		2>再 判断类型是否一致（是否为同一类型）,
		3>最后 比较内容是否一致
3.equals 重写原则:
	1>对称性	2>自反性	3>传递性	4>一致性
4.HashMap原理:
	1>hashing概念:
		根据一定的算法对键(key)进行hash运算,生成一个int值,相当于对一个数据进行摘要运算.
	2>解决碰撞:
		当两个键的hash值相同时,调用equals方法进行比较,相同将旧的键值对抛弃,不同则将新的键值对存储于*链表中;
	3>get和put:
		#1 get时首先根据key值的hashcode查找元素,如果第一个元素的key值不对,则调用其next方法继续寻找下一个元素;
		#2 put时根据key值hashcode决定存放位置(bucket),如果该位置已有其他元素,则按照碰撞原则进行存放;
	4>key值不可变对象:
		以为要根据key值的hashcode来计算元素存放位置,所以key值应当为不可变对象;
	5>多线程竞争:
		当HashMap的负载因子超过0.75(即大小超过了75%),则会重新调整大小,大小便为原来的2倍,
		如果两个线程同时对map进行扩容,则会出现多线程竞争,造成死锁
	深入HashMap:
	1>HashMap初始长度:
		#1 HashMap初始长度为16,扩容时也是2倍扩充,即大小总为2的指数
		#2 hash值的计算:  
			简单的方法是用key值的hashcode对map长度进行取模运算,但效率太低;
			HashMap使用key的hashcode[HashCode(key)]和 Map长度-1[map.length-1]进行 *与* 位运算(先将两者转为2进制,结果再转为 十进制);
		#3 长度为何为2的指数:
			当map长度为2指数时,length-1 的二进制总为 1111...1,当 与 运算时,index值总是取决于hashcode最后几位;
			这样做实现了Hash算法的 *均匀分布*原则
5.参数传递:
	1>对于基本数据类型,eg: a=1 func(int a){a=2}; 
		方法内对于形参的修改不会影响原来的值
	2>对于引用类型的数据(对象),eg: p=new Person();func(Person p){//p=new Person();}
		(1)方法内形参引用指向新的对象时,改变形参对象不会影响外部实参对象;
		(2)方法内形参引用并未指向新的对象,即实参和形参指向同一个对象的地址,则改变形参对象也会改变外部实参对象;
	# tips:
		Java 参数传递都是值传递,不存在引用传递
6.重写和重载:
	#重载:
		1> 方法名相同,参数类型,顺序,个数不同
		2> 与返回值无关,不能单纯修改返回值来重载方法
		3> 存在于父类和子类,同类中
		4> 可以抛出不同的异常,有不同的修饰符
	#重写:
		1> 方法名相同,参数列表相同,返回值类型相同(只有内部逻辑不同);
		2> 存在于父子类中;
		3> 子类的访问权限大于等于父类;
		4> 构造方法不能被重写,声明为 static,final 的方法不能被重写,但 static 可以被重新声明
		5> 子类不能抛出比父类更广泛的运行时异常
7.抽象类和接口:
	# 抽象类:
		1>抽象类可以有构造方法和成员变量;
		2>抽象类可以有抽象方法和具体方法;
		2>抽象类可以有静态方法;
		3>子类继承抽象类必须实现其中的抽象方法,否则也需要声明为抽象方法
		4>抽象类的方法可以用任意修饰符
		# tips:
			抽象方法不能被 static(静态方法无法被重写),native(java本地方法,使用C另外实现),synchronized(同步需要实现细节,而抽象不涉及细节) 修饰
	# 接口:
		1>接口只能有抽象方法,不能有构造方法;
		2>接口默认的修饰符是public,定义的成员变量其实是 常量
		3>接口中不能有静态方法;
	#相同:
		1>可以将接口和抽象类当做引用类型;
		2>两者均不能被实例化:
		3>继承抽象类或者实现接口的类都必须实现其中的抽象方法;
8.静态变量和实例变量:
	1>静态变量被 static 修饰,也叫类变量,不属于任何一个实例,在内存中只有一个,多个实例共享;
	2>实例变量 属于类的一个实例,需要先实例化一个类
9.对String直接操作等于新建String对象,频繁对String操作使用 StringBuilder 
	Tips: 
		1>StringBuffer 也可对String进行操作,是线程安全的,而StringBuilder非线程安全,但速度快
		2>String 用 "+" 连接时其实也是调用StringBuilder操作,对String使用简单的"+"操作,效率与Builder差不多
		但对String频繁操作,比如将"+"操作放在循环体中,则底层会创建很多的StringBuilder对象,效率低并造成内存浪费;
		所以,使用StringBuilder对象至于循环之外,且不与"+"混用(混用也会创建不同的StringBuilder对象)
10.Java异常分类:
	1>按照处理时机分为 编译时异常(也叫强制性异常或者checked异常),运行时异常 RuntimeException.
	2>checked异常必须被显式的处理,使用 try...catch 或在方法上声明抛出;
	3>运行时异常则由异常处理类(可自定义)来处理
11.数据类型及大小:
				字节    bit
	1> byte  	 1 		8;
	2> short 	 2		16;
	3> int		 4		32;
	4> long      8		64;
	5> float     4      32;
	6> double    8		64;
	7> char      2		16;
	8> boolean	 1		8;
	#Tips:
	String 是引用类型,底层用char数组实现
12.String常量及引用相加:
	String str="abc";
	String str1,str2="a","bc";
	String str3="a"+"bc";
	String str4=str1+str2;
	str==str3;//True
	str==str4;//False
	str==
	# Tips:
		1>String 常量相加是在栈中常量池进行操作;
		  而 引用相加 则是两个String对象进行相加,在堆中进行;
		  两者会产生不同的对象
		2>String 
13.String.intern():
	1> String.intern()返回String在常量池中对象的引用,如果常量池没有则将当前String添加进常量池;
	2> intern 就是为了减少内存消耗
	3> JDK 1.7+版本:
		eg:
		String s1=new String("1")+new String("1");
		s1.intern();
		s2="11";
		s1==s2; //true
		//s1==s2; //false jdk 1.6--版本
		JDK 1.7 常量池被放入了堆中进行操作,故s1在经过intern之后(指向堆中常量池"11"),和s2指向是一个对象
14.Java 8日期时间特性:
	1> 不变性(安全性),所有时间日期类不可变,适应多线程环境;
	2> 关注点分离: 人可读时间和 unixtamstap 机器时间分离;
	3> 清晰: 所有类中方法都被明确定义.都实现了format和parse方法;
	4> 实用性: 所有新的日期/时间 Api都实现了一系列通用方法用以完成常用操作,如日期/时间加减
	5> 扩展性: 基于Iso-8601标准,但也可以应用于非ISo日历;
15.short&&int:
	short s=1; s=s+1; //编译失败
			   s+=1;  //编译成功
	1> s+1 时,1 属于 int 类型,相加后结果为int类型;
	2> s+=1,相当于s=(short)(s+1),自动进行了数据类型转换;
16.Integer的创建:
	1> 创建Integer对象时,如果传入的 int 值在 -128~127 时,则将该对象加入常量池,后续该值的integer对象指向同一个对象;
	2> 超出-128~127 范围的,则每次都会新建integer对象,即使两个对象的值相同.
17.Java接口的继承:
	1>接口可以被继承;
	2>继承者也是接口,且可以重载override父接口(P_Interface)中抽象方法,重载后该方法在子接口(C_Interface)中可变为具体方法;
	3>当实现类(G_Class) implements 实现子接口(C_Interface),重载方法时可以显式的调用子接口中的实现,Eg:
		@override
		public void hello(){
			//可以实现多个接口,显式调用接口实现方法
			//也可在实现类中自己实现
			C_Interface_1.super.hello();
			C_Interface_2.super.hello();
		}
18.Java对象的克隆Clone:
	两种方式
	1> 实现Cloneable接口并重写Object类中的 clone 方法;
	2> 实现Serializable,利用序列化和反序列化来克隆,这样得到的对象相当于深拷贝;
19.Java序列化Serializable:
	#序列化特点:
		1> 父类可以被序列化则子类也可以被序列化
		2> static 静态变量和transient(临时数据)不能被序列化:
			静态变量或常量属于类而不属于某个对象,序列化是针对对象的操作;
		3> 如果父类没有实现 Serializable 接口,那么反序列化子类时会调用父类的 空构造 方法,如果父类没有该方法则会报错
			如果父类实现了Serializable,则反序列化子类时不会调用父类空构造
	#Java序列化过程
		1> 使用 ObjectOutputStream.rwiteObject() 将对象写入文件流或者字节流中;
		2> 使用 ObjectInputStream.readObject(),从文件流或字节流等流中反序列化出来;
20.HashMap,HashTable,HashSet:
	1>HashMap实现参照之前;
	2>HashTable:
		(1)HashTable基于Dictionary类,而HashMap实现了Map接口;
		(2)HashTable不允许 null 作为键或者值,而HashMap允许一个 null 键和多个 null 值;
		(3)HashTable线程安全,HashMap不安全;
		(4)HashTable的hash值直接使用,而HashMap计算完hashCode之后会进行其他计算(与Map长度值-1 做与运算);
		(5)HashTable初始11,扩充时2*old+1,HashMap初始16,扩充时2*old;
	3>HashSet底层使用HashMap实现,元素值都存在于HashMap key中,value为一个常量对象(new Object()),非线程安全;
	#Tips:
		1>Vector也是线程安全的;
		2>线程安全的集合类型无非就是在核心方法上增加 synchronized 关键字;
		3>Collections工具类提供的API可以让不安全的集合变为线程安全的,Eg:
			Collections.synchronizedCollection(c);
			Collections.synchronizedList(l);
			...
21.ArrayList内部实现:
	1> ArrayList内部维护一个 Object[] 数组;
	2> 当List需要扩容时:
		(1) 当前长度小于6,则一次性分配12个长度;
		(2) 当前长度大于6,则一次性增加当前长度的 1/2(new_size=size+size>>>1,移位运算比 /2 数学计算快).
22.ConcurrentHashMap:
	1>JDK 1.8之前,通过HashEntry和Segment数组实现,一个Map由n个Segment数组组成,一个Segment包含n个HashEntry键值对
	2>内部采用分段锁机制,最大支持16个线程并发,访问不同的table块

23.数组和链表:
	1> 数组在内存中需要一段连续的空间,且创建时需要指定大小,空间利用率不高,不利于扩展,查询快速,修改缓慢;
	2> 链表不需要连续的内存空间,动态扩展大小,适合频繁的插入,删除操作
24.Static代码块执行时机:
	1>调用静态变量或静态方法时(注:当静态变量被 final 修饰即常量时,不会调用static代码块);
	2>类初始化时,static 代码块先于初始化方法执行;
25.ThreadLocal:
	线程局部变量 ，是 Java中一种较为特殊的线程绑定机制，可以为每一个使用该变量的线程都提供一个变量值的副本，
	并且每一个线程都可以独立地改变自己的副本，而不会与其它线程的副本发生冲突.
26.Runnable和Callable的区别:
	1>Runnable 规定的方法是run(),Callable规定的方法是call();
	2>run方法没有返回值,call方法可以有返回值;
	3>call方法可以抛出异常,run方法不能抛出异常;
	4>运行Callable任务可以获得一个 Future对象,表示异步计算的结果,可以获取任务结果,状态,对任务进行终止;
27.ExecutorService/Executors:
	1>ExecutorService pool=Executors.newFixedThreadPool(3);
		通过线程池工厂类 Executors 可创建 固定大小线程池,可变连接池,单一连接池,延迟连接池
	2>固定大小连接池: 无论添加多少个任务,始终起指定的N各线程去执行任务
	  其他类型连接池根据名称即可推断特点;
	3>连接池的执行方式:
		execute(Runnable):无法得知 Runnable对象的执行结果
		submit(Runnable/Callable): 返回一个Future对象,通过future对象可以得知任务的执行状态,如果执行的是Callable对象,则Future对象还可以获取执行Callable执行后的返回值;
		invokeAny(Set<Callable>/List<Callable>): 接收一个Callable对象的集合,只要集合中任何一个任务结束(正常结束或者抛出异常),则其他Callable任务讲被终止,所以返回的是单一结果;
		invokeAll(et<Callable>/List<Callable>): 接收一个Callable对象的集合,返回一个Future对象的集合,标识所有任务的结果,会执行完所有任务(但是无法得知单一任务是正常结束还是异常);
	4>连接池的终止方式:
		shutdown: 终止空闲的线程,已经提交任务的无法终止;
		shutdownNow:interrupt所有线程,因此大部分线程将被终止.
28.ForkJoinPool:
	1>合并和分叉线程池;
	2>允许执行RecursiveAction(无返回值)和RecursiveTask(有返回值);
	3>自定义任务类可以继承 RecursiveAction 或 RecursiveTask;
	4>任务可以进一步被拆分成若干个子任务;
	5>ForkJoinPool.invoke(RecursiveAction/RecursiveTask),获取结果.
29.Java并发队列:
	#阻塞队列 BlockingQueue(使用锁实现)
		1>公平锁:在并发环境中,每个线程在获取锁时会先查看此锁维护的等待队列,如果为空或者当前线程排第一,则该线程获得锁
			非公平锁:每个线程上来就尝试获得锁,如果获取失败则再采用公平锁的机制获取锁
		2>
	#非阻塞队列(使用CAS算法实现)
	
30.Java线程池排队和并发策略:
	1>线程池参数解读:
		ThreadPoolExecutor(int corePoolSize,
		  int maximumPoolSize,
		  long keepAliveTime,
		  TimeUnit unit,
		  BlockingQueue<Runnable> workQueue,
		  ThreadFactory threadFactory,
		  RejectedExecutionHandler handler)
		(1)corePoolSize:核心线程数(池中保留线程数),包括空闲线程.线程池初始化并不会立即创建新线程,直到有任务提交,才新建线程使线程数量逐渐达到corePoolSize;
		(2)maximumPoolSize:最大线程数.当核心线程数满,并且阻塞队列也满时,才会判断当前线程数是否小于最大线程数,从而决定是否新建线程;
		(3)keepAliveTime:空闲线程的存活时间,当超过设定时间后,大于核心线程数的空闲线程会被终止(也可通过其他参数设置核心线程中的空闲线程也被终止);
		(4)unit:keepAliveTime 的时间单位;
		(5)workQueue:当线程数量大于等于核心线程数时,用于存储任务的队列,包括有界,无界队列,优先级队列等;
		(6)threadFactory:执行程序创建新线程时的工厂
		(7)handler:当最大线程数和阻塞队列都满时,线程的抛弃策略(详细见之后)
	2>线程池阻塞队列:
		(1)无界队列 LinkedBlockingQueue:
			newSingleThreadExecutor 和 newFixedThreadPool 都使用无界队列
			##当无界队列不设定大小时,池中创建的线程不会超过 corePoolSize,此时 maximumPoolSize(最大线程数)也就没有限制意义,多余的任务会缓存进无界队列;
			##只有当无界队列设定了大小时,如果任务数量超过最大线程数和队列大小之和时,才会用到拒绝策略
			#Tips: 使用无界队列时,队列大小没有限制,任务过多时可能会造成 OOM;
		(2)有界队列:
			ArrayBlockingQueue:
			PriorityBlockingQueue: 任务优先级排序需要任务的Comparator来决定
			#有界队列能有效防止资源耗尽,但可能比较难控制,需要队列大小和线程池大小配合使用
		(3)直接提交(同步移交队列):
			SynchronousQueue:并不是一个真正的队列,而是一种移交机制.类似于生产者-消费者模式,一端将任务放入队列,一端(线程池)取出任务;
			#直接提交,线程池不会对任务进行缓存,每当有新任务时,会直接创建新线程来执行任务,需要线程池有无限容量
		(4)延时队列:
			DelayedWorkQueue:是 ScheduledThreadPoolExecutor 的静态内部类,定时线程池使用DelayedWorkQueue来创建线程
			#执行线程时可指定延迟时间
	3>线程池拒绝策略:
		(1)饱和策略:AbortPolicy
			当任务数量大于线程池最大线程数和阻塞队列容量时,丢弃新添加的任务并抛出异常 RejectedExecutionException
			#这种情况需要线程池有限制数量,而阻塞队列需要时有界队列或限制大小的无界队列.
		(2)丢弃策略 DiscardPolicy:
			当任务数量大于最大线程数和队列容量时,新增加的任务将被丢去,但不会抛出异常
		(3)丢弃任务策略 DiscardOldestPolicy:
			当任务数量大于最大线程数和队列容量时,丢弃缓存在队列中的头部元素即最先加入队列的元素
		(4)调用者运行策略 CallerRunsPolicy:
			当线程池饱和之后,新添加的任务将退回给调用线程池的主线程直接运行,主线程运行任务期间无法再提交新的任务
31.Java多线程创建方式:
	1>继承Thread类并重写run方法,通过start启动线程,本质上还是调用run
	2>实现Runnable接口并实现run方法;
	3>通过 ExecutorService 创建多线程:
		**实现Callable接口,通过submit(callable)返回一个Future对象,从而获得多线程线程执行的返回值
32.wait和sleep:
	1>在等待时 wait 会释放锁,用于线程间操作;
	2>sleep会一直持有锁,用于暂停线程
33.synchronized和volatile作用及区别:
	1>变量被volatile修饰时:
		**保证不同线程对变量修改时的可见性,即一个线程对变量进行修改,另一个线程立即可见;
		**禁止指令重排序: volatile 本质实在告诉jvm当前变量在工作内存中(寄存器)是不确定的,需要从主内存中读取.
	2>变量(方法或类)被 synchronized 修饰时,只有一个线程能否访问,其他线程被阻止
	不同点:
		#1.volatile 仅能使用在变量级别,而 synchronized 可以使用在变量,方法和类上;
		#2.volatile 仅能保证变量修改的可见性,不能保证同步和原子性,synchronized 不仅保证可见性还能保证原子性;
		#3.volatile 是非阻塞式的,而 synchronized 是阻塞式的
34.线程池优点:
	1>降低资源消耗.重复利用已创建的线程,避免了线程频繁创建和销毁的内存消耗;
	2>提高响应速度.任务到达时,用已创建线程直接执行,没有等待线程创建的时间消耗;
	3>方便管理.线程频繁,大量创建会加大系统资源消耗,影响系统稳定性,利用线程池可对线程进行控制和调优.
35.信号量Semaphore:
	1>当需要限制某资源(方法等)的并发访问量时使用新信号量 new Semaphore(int num):num 表示限制数量及并发访问的线程数;
	2>Semaphore.acquire 和 Semaphore.relaese() 配合使用对资源进行控制访问,释放一个信号量才能有新的线程获得资源访问
	#需要注意的是 Semaphore 并不能保证资源的同步,只是保证了自身的同步,所以需要自己实现资源的同步
36.线程间数据传递:
	当A,B,C三个线程并发执行而B,C线程需要A线程运行结果时,可使用信号量去控制;
	方法:
		1>建立容量为0的限号量,在A执行完之后释放两个信号量
		2>在B,C线程中尝试获取信号量,如果获取不到线程会阻塞等待
37.Lock和synchronized:
	在同一个类中对两个不同的方法使用lock和synchronized关键字进行加锁会有不同的结果
	1>Lock.ReentrantLock 在一个类中使用同一个lock对象:
		(1)多个线程不能访问同一个类实例的两个同步方法,因为两个方法公用一个lock对象;
		(2)多个线程可以访问不同类实例的同步方法;
	2>synchronized:
		(1)多个线程不能访问同一个类实例的两个同步方法,因为 synchronized 是对象锁;
		(2)多个线程可以访问不同类实例的同步方法;
		(3)***当一个类中有两个线程(Runnable1,Runnable2)对象的 run 方法中使用 synchronized(this) 对对象进行加锁,
			当不同线程(Thread1,Thread2)访问同一个类实例的**两个线程(Runnable1,Runnable2)**时,Runnable1,Runnable2中的 this 对象其实是两个类实例
			故,多个线程可以访问同一个类实例的两个Runnable对象
38.如何避免线程死锁:
	1>设定线程间加锁顺序;
	2>设置线程加锁的时限(超时不再获取锁并释放已占有的锁)
39.线程间通信:
	1>通过共享变量:
		当通过共享变量传递信息时,需要注意线程的先后执行顺序,一个线程需要另一个线程的执行结果:
		(1)在ThreadB的run方法中,通过ThreadA.join来使线程A执行完毕后再获取共享变量结果;
		(2)通过信号量 Semaphore 来实现
	2>通过 线程的 wait/notify 机制
40.同步线程及线程调度的相关方法:
	sleep,wait,notify(无法确定唤醒哪个线程,由jvm决定),notifyAll(唤醒所有等待的线程)
41.Java内部类:
	Java内部类分为静态内部类和普通内部类
	1>静态内部类
		静态内部类的创建不依赖于外部类,无需初始化外部类;
	2>非静态内部类
		调用(创建)非静态内部类时,必须创建外部类的实例

42.Java反射机制:
	1>在程序运行期间,可以动态获取并调用一个对象的属性和方法,称为反射,增强了语言的灵活性;
	2>Java反射其实是先获取到要反射类的字节码,有三种方式:
		(1)Class.forName(className);(2)类名.class;(3)this.getClass()
		然后将字节码中的方法,变量,构造函数映射成相应的Method,Field,Constructor对象.
43.动态代理和静态代理的区别:
	1>静态代理通常只代理一个类,而动态代理可以代理一个接口下的多个实现类;
	2>静态代理事先知道要代理的是什么,动态代理实现不需要知道,运行期才知道;
	3>动态代理通过实现InvocationHandler接口的invoke方法,被代理的是接口的实现类;
	4>CGLIB通过运行时动态修改字节码达到修改类的目的,应用于SpringAOP
44.设计模式:
	1>一般认为Java共有23种设计模式,分为三大类:
		(1)创建型模式,五种:工厂方法模式,抽象工厂模式,单例模式,建造者模式,原型模式;
		(2)结构型模式,七种:适配器模式,装饰器模式,代理模式,外观模式,桥接模式,组合模式,享元模式;
		(3)行为型模式，共十一种： 策略模式、模板方法模式、 观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、
		   状态模式、访问者模式、中介者模式、解释器模式
	2>常见设计模式:
	**单例模式:
		(1)饿汉式:使用静态变量instance 在类加载时就创建单例,线程安全但无论是否使用都会存在该实例,内存浪费;
		(2)懒汉式:通过volatile关键字修饰instance,避免jvm进行指令冲排序,并使用双重锁保证线程安全;
		(3)静态内部类:**推荐**,使用静态内部类实现创建单例,可以实现延迟加载的饿汉式设计,并保证线程安全;
	**工厂模式:
		(1)普通工厂:建立一个工厂类,对实现了同一接口的实现类进行实例的创建(比如:通过传递给工厂的字符串创建对应的实现类并返回实例);
		(2)多个工厂方法模式:建立一个工厂类,提供多个方法,分别创建不同的实例,根据需要调用工厂类的响应方法;
		(3)静态工厂方法模式:将多个工厂方法模式中的方法声明为静态方法,调用时不用实例化工厂类;
		(4)抽象工厂模式:建立多个工厂类,如果需要增加功能,直接新增工厂类
	**建造者模式:
		(1)建造者模式可以创建具有复杂属性的产品或一系列具有相同属性的产品;
		(2)客户端指定某一类型的建造者来创建产品,隐藏产品的创建细节;
		(3)优点是隐藏实现细节,实现代码复用,缺点是创建的产品具有相同的属性,不适用于需要不同属性产品的场景.
	**适配器模式:
		将某个类的接口转换成客户端所期望的另一个接口表示,目的是消除接口和类不兼容的问题,适配器一般会继承一个原始类并实现一个接口,
		然后在接口的某个实现方法中调用原始类中的某个方法
		(1)类的适配器,即采用上述方法;
		(2)对象的适配器,对象适配器不在继承原始类,而是持有一个原始类的实例,在实现接口方法时修改为原始类方法;
		(3)接口的适配器: 用一个抽象类去实现需要适配的接口,从而形成一个接口适配器.
		   客户端继承此抽象类(适配器),只用根据需要重写其中的方法,而不用像原来那样必须实现接口中的所有方法.
	**装饰模式:
		(1)装饰模式就是在不改变原来对象的基础上动态给对象增加功能的设计模式;
		(2)要求装饰器和被装饰器都实现同一个接口
	**策略模式:
		策略模式定义了一些列算法并封装起来,决定权在用户,系统本身提供不同的算法实现,由用户决定使用什么算法
		常用在算法决策系统中
	**观察者模式:
		类似于邮件订阅和RSS订阅;
		当一个对象变化是,依赖于该对象的其他对象都会收到通知并随着变化
45.JVM垃圾回收机制和常用算法:
	1>搜索算法
		(1)引用计数算法(jdk 1.1之后已废弃):
			对每个对象的引用进行计数,当该对象引用计数为0时,回收对象,但是不能解决对象之间相互引用的问题;
		(2)根搜索算法:
			通过"GC Roots"对象作为起点向下搜索,搜索通过的路径成为"引用链",当一个对象没有被GC Roots的引用链连接的时候,说明该对象不可用;
			GC Roots对象包括:
				**虚拟机栈中引用的对象
				**方法区域中类静态属性引用的对象
				**方法区域中常量引用的对象
				**本地方法栈中JNI(Native方法)引用的对象
	2>回收算法
		(1)标记-清除:
			**标记阶段:根据搜索算法,标记需要回收的对象;
			**清除阶段:对已被标记的对象进行清除;
			#缺点: 标记清除效率不高,会产生不连续的内存空间,不利于存储大的内存对象
		(2)复制算法:
			**每次只使用一半内存,当垃圾回收时将存活的内存复制到另一半内存里,然后对原来的一半内存进行清理
			**缺点是内存利用率不高,每次只能使用一半内存
			**用于Jvm对新生代的回收,由于新生代中98%对象存活时间短,划分比例为大约为 8:1(原始使用内存:闲置内存)
		(3)标记-整理算法:
			**与标记清除算法类似,但是将被标记的存活对象往内存的一端移动,然后清除边界之外的对象
			**提高了内存利用率,用在老年代的内存回收
		(4)分代回收:
			**根据对象存活时间把内存分为新生代和老年代,使用不同的垃圾回收算法.
			**新生代采用复制算法,老年代采用标记-整理算法.
			
		#堆内存中 新生代:老年代=1:2
		#新生代中  Eden:From Survivor:To Survivor=8:1:1
46.运行时数据区域:
	1>.程序计数器:
		<1>可以看做是当前线程可执行的字节码行号指示器,所以,每个线程都有单独的程度计数器;
		<2>如果程序运行的是java方法,则指向虚拟机字节码指令地址;如果运行的是Native方法,则为0;
		<3>此内存区域是唯一一个没有规定 OOM 的区域.
	2>.Java虚拟机栈:
		<1>与程序计数器一样,也是线程私有的,生命周期等同于线程周期;
		<2>每个方法被执行时都会创建一个栈桢,用于存储局部变量表等信息;
		<3>局部变量表所需的内存空间在编译期即分配完成.
	3>.本地方法栈:
		<1>与Java虚拟机栈发挥的作用非常相似,区别在于:
			<1.1>虚拟机栈是为虚拟机调用java方法服务,而本地方法栈是为虚拟机调用本地方法服务
		<2>同样会抛出 StackOverFlow 和 OutOfMemery 异常
	4>.Java堆(Java Heap):
		<1>Java堆是所有线程共享的一块区域,在虚拟机启动时创建;
		<2>主要存放对象实例和数组(绝大部分);
		<3>在物理内存上可以是不连续的一块,可以扩展
	5>.方法区:
		<1>也是线程共享的内存区域,用于存放已被虚拟机加载的 类信息,常量,静态变量,和即时编译器编译后的代码等数据;
		<2>物理内存可以不连续,空间可扩展也可固定,可以不实现垃圾回收;
		<3>该部分的垃圾回收主要针对常量池
	6>.运行时常量池:
		<1>属于方法区的一部分
		<2>具备动态特性,可将运行时产生的常量放入其中,比如String的itern()
	7>.直接内存:
		<1>并不是虚拟机运行时的内存区域,也不是虚拟机规范中定义的内存区域;
		<2>NIO中,作为缓冲区buff来使用,Native方法来分配堆外内存
47.*Java中引用类型都有哪些*:
	1>强引用:
		一般程序中使用的都是强引用,比如 a=new Object(),对于强引用,虚拟机即使抛出OOM也不会回收强引用对象;
	2>软引用:
		SoftReference,当Java虚拟机内存不足时,就会对软引用对象进行回收,适用于做内存敏感的高速缓存
	3>弱引用:
		WeakReference,不管虚拟机内存是否充足,只要发现了软引用就会对其进行回收,适用于偶尔使用的对象
	4>虚引用:
		虚引用任何时候都可能会被gc回收,该引用形同虚设,不影响对象的生命周期,主要用来监控对象被垃圾回收的时机
48.Heap和Stack的区别:
	1>栈是有结构的,每个区块按照一定的次序存放,连续的内存地址;Heap是没有结构的,数据可以任意存放,不连续的内存空间,
	  因此,stack的寻址速度要快于Heap;
	2>每个线程分配一个Stack,每个进程分配一个Heap,也就是说,Stack是线程独占的,而Heap是线程共享的;
	3>Stack创建的时候,大小已确定,超过就会报StackOverFlow错误,Heap的大小不确定,会根据需要不断增加;
49.Java类加载器的种类:
	1>根加载器(BootStrap) c++编写,看不到源码;
	2>扩展类加载器Extension;
	3>系统(应用)类加载器(System/App);
	4>自定义加载器,必须继承ClassLoder
50.类什么时候初始化:
	1>创建类的实例,即new一个对象;
	2>访问某个类的静态变量;
	3>调用类的静态方法;
	4>反射(Class.forName("类路径"));
	5>初始化一个类的子类(会初始化子类的父类);
	6>JVM启动时标明的启动类
