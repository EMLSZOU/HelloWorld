1.python函数传递?
	1)当一个引用传递给函数的时候,函数自动复制一份引用,函数中引用和外部没有没有关系了;
	2)对于可变变量,对该引用的变量进行操作时会改变原来变量的值;而对于不可变的(str,tuple,int等),不会影响外部引用指向的值
	
2.元类?
	1)元类 type 或者继承自type的其他类
	2)元类是用来创造其他类的 MyClass=type('Foo',(),{}),很少用到
	3)Django orm 用元类来实现  参考 models 定义
	
3.实例方法,类方法,静态方法?
	1)实例方法:必须实例化该类才能被调用(Py3不实例化直接用用类调用,会直接返回这个类对象内存地址)
	2)类方法:无需实例化这个类而能被直接调用(也可以被实例调用),可以被子类继承和重写;
		传入的都是类对象,主要用于工厂方法,具体交给子类实现
	3)静态方法:
		无需实例化即可调用,而多个实例对象也可以共用一个静态方法;
		静态方法不能访问类变量和实例变量.

4.Python的自省?
	程序运行时能够知道对象的类型或属性,例如(type,dir,hasAttr,isinstance 等)

5.字典推导式?
	Py2.7时加入
	{key:val for (key,val) in dict.items()}

6.Python中单下划线和双下划线?
	1)单下划线 _func :自定义变量或函数,不能通过 from* import 导入,只能通过类实例来访问;
	2)双下划线 __func:自定义私有属性或函数,即使实例化或子类继承也不能被(直接)访问(解释器会改为_class__func来进行访问,但不同解释器规则可能不一样)
	3)__attr__,两头下划线: Python 内部保留的属性名称易区别于自定义名称,防止冲突
	Tip:Python 中没有 protected 这个说法,要么共有,要么私有
7.HTTP请求过程?
	7.1浏览器向服务器发送HTTP请求:
		7.1.1.包括方法,路径,域名以及其他的Header相关
		7.1.2. 如果是post请求,那么请求还包含一个body,里面是用户提交的数据
	7.2 服务器向浏览器返回HTTP响应:
		7.2.1 Header包括响应代码 200--->OK; 3xx-->重定向; 4xx-->客户端发送的请求错误; 5xx-->服务器端内部处理时发生错误
		7.2.2. 响应类型:由Content-Type决定,即使请求地址中包含1.jpg也未必是图片
		7.2.3. 服务器响应内容会放在Body里面,包含HTML源码;
		7.2.4. 如果浏览器还需要向服务器请求其他资源,图片,视频等,就会重复以上步骤

8.协程?
	8.1 协程是在一个子线程中切换子程序;
	8.2 没有切换线程的开销,效率比较高,不需要多线程的锁机制,只需要判断程序执行的状态即可;
	8.3 对于多核 CPU 可以使用 多线程+协程 来获得很高的效率
	9.4 Python的协程通过 generator 来实现

9.asyncio?
	9.1 asyncio 提供完善的异步 io 支持,通过 yield from 实现
	9.2 协程方法上加注解 @asyncio.coroutine

10.async,await?
	Py 3.5 开始简化 async 的调用,
	10.1 只需要将注解 @asyncio.coroutine 改为 async def foo():
	10.2 将 yield from 改为 await
11.	Python 字符串格式化:%s 和 .format?
	都是占位符,.format更灵活(注意下表越界)
	对于 %s 如果变量值是一个元组,则采用 %(name,)的方式

12.迭代器和生成器?
	12.1 迭代器:每次调用该对象时都会返回自身的下一个元素,
	12.2 生成器: 

13.*args 和 **kwargs?
	13.1 *args 允许传递任意数量的参数  也可以 *mylist 表示传递一个列表
	13.2 **kwargs 允许使用没有事先定义的参数名称  也可以**mydict传递字典类型参数

14.面向切面编程AOP和装饰器?
	14.1 AOP是在程序运行期间,再不修改源代码基础上动态给函数增加功能,通过预编译或运行期动态代理
	14.2 装饰器 Decorator 程序运行期间动态给函数增加功能
	14.3 常用于 日志添加,性能检测等  降低了耦合性和侵入性
	
15.鸭子类型?
	15.1 不关心具体对象类型,只关心行为,只要行为看起来像鸭子就是鸭子类型;
	15.2 比如Python中的 file_like 的对象,比如stringIo,Gzipfile 等有很多相同的方法,都可以当做文件类型使用;
	15.3 再比如只要对象时可迭代的 list,tuple,dict,都可以使用extend方法
	15.4 动态类型语言的而鸭子类型提高了语言的灵活性

16.Python重载?
	16.1 重载的意义,方法参数类型不同,参数个数不同,而且函数功能相同,这种情况下使用重载;
	16.2 Python中,参数类型可变,置于参数个数,可以使用缺省值 因此,Python无需重载

17.新式类和旧式类?
	17.1 Python 2 中默认都是 旧式类(经典类),创建新式类需要显式的继承 Object
	17.2 Py3 默认都是创建新式类
	17.3 新式类  可以使用 __slots__ 函数限制类属性 __class__直接显式本类的类型 增加了__getattrubiute__属性
	17.3 在继承关系搜索时,旧式类深度优先,新式类广度优先(先水平再向上)
	
18. __new__和__init__的区别?
	18.1 __new__ 是一个静态方法,返回一个创建的实例
	19.2 __init__ 初始化方法,什么都不返回

19.super()?
	19.1 super 用来调用当前类父类的初始化方法 :
		class Boo(Aoo):
			super(Aoo,self).__init__()
	19.2 Python的多继承类是通过mro的方式来保证各个父类的函数被逐一调用，而且保证每个父类函数
       只调用一次（如果每个类都使用super）
	   
20.单例模式?集中常用的方法?
	20.1 使用 __new__ 来创建单例,将类的实例在初始化的时候绑定到类的属性 _instance 上面,之后初始化时返回 最后一次 初始化的实例
		class Singleton(object):
			def __new__(cls,*args,**kwargs):
				if not cls.hasattr(cls,"_instance"):
					cls._instance=super(Singleton,cls).__new__(cls)
				return cls._instance
		
		class Aoo(Singleton):
			def __init__(self,name):
				self.name=name
		
		a=Aoo("Bob")
		b=Aoo("Join")
		print (id(a),a.name) # 111 Join
		print(id(b),b.name)  # 111 join
		所有实例的 Id 相同
	20.2 将所有实例的字典绑定为一个 __dict__
		20.2.1在父类中 定义一个字典 _shared_dict
			obj=super(Singleton,cls).__new__(cls)
			obj.__dict__= cls._shared_dict
			return obj
		这样实例化出的子类 id 是不一致的;
		20.2.2 如果想使子类在作为key时 key是一个 例如 dict1[Aoo] 和 dict2[Boo] 是一个key,在父类中重写__hash__ 和 _-eq__方法:
			def __hsh__(self):
				return 1
			def __eq__(self,other):
				try:
					return self.__dict__==other.__dict__
				except:
					return False
	20.3 最简单的方法:将名字绑定到实例上 即 singleton=singleton() 则singleton就是它自己类的唯一对象 
			
21.Python作用域?
	Python 变量查找的范围:
		本地作用域--->当前作用域被嵌入的本地作用域（Enclosing locals）--->全局/模块作用域(global)--->内置作用域(built_in) 

22.GIL线程全局锁?
	22.1 Python 为了保证线程安全采取的独立线程运行机制,即 一个cpu核心只能在同一时间运行一个线程
	22.2 GIL 锁 只是 Cpython 解释器特有,并非 Python 语言本身的机制,Jpython 就没有GIL锁

23.多线程与多进程选择?
	23.1 单核Cpu 多线程:
		23.1.1 IO 密集型 使用多线程 因为进程开销巨大,多进程切换速度不如多线程
		23.1.2 计算密集型  依然使用多线程 原因同上
	23.2 多核 CPU
		23.2.1 IO 密集型 再多的核心也解决不了IO问题  使用多线程
		23.2.2 计算密集型  Python中同一进程下只有一个线程同时运行,使用多线程

23.闭包?	
	23.1 函数中又定义了一个函数,内部函数被当做外部函数的返回值返回,并且外部函数的参数和局部变量被保留在内部函数中,这种程序结构成为闭包;
	23.2.外部函数的返回值也是一个函数,只有当该函数被调用时才会真正执行程序
	23.3 内部函数不能引用外部函数的循环变量,原因同上
	23.4 闭包提高了方法的复用
	
24.lambda?
	lambda 定义了一个匿名函数,并不能提高执行效率,只是让代码看起来更加简洁
	表达式中不要包含 循环 如果能使用 for in 就不要使用 lambda
	
25.函数式编程?
	函数式编程可以归为面向过程的编程方式;
	特点:允许一个函数接收另一个函数作为参数,允许返回值也是一个函数
	三个常用方法: map reduce filter

26.Python里的拷贝?
	26.1 浅拷贝 shallow copy 复制了一个对象,但对于对象中的元素,依然使用引用
	26.2 深拷贝 deep copy 复制一个容器对象,以及容器中的子元素,属于完全复制

27.Python垃圾回收机制?
	主要使用引用计数来跟踪和回收垃圾,在 引用计数 的基础上,采用 标记--清除 来解决容器对象可能产生的循环引用的问题,通过分代回收以空间换时间的方式换取垃圾回收效率
	27.1 引用计数:
		对对象的引用进行计数
	27.2 标记--清除:
		按需分配,当内存不足时,将内存中所有可以访问到的对象打上标记,然后进行清除
	27.3 分代回收:
		将内存块按存活时间分为不同的集合,称为代.根据存活时间不同进行分代回收
	
28.Python is 和 ==	?
	is 判断内存地址,是不是同一个对象或类型
	== 只判断值

29.read,readline和readlines?
	read 读取整个文件
	redline 读取下一行,使用生成器方法
	readlines 读取整个文件到一个迭代器以供我们遍历

30.Python 2和3的差别?
	30.1 性能差别:一般来讲,python3 运行速度比 python2 慢
	30.2 语法差别:
		30.2.1 去除了 <> 全部改用 !==;
		30.2.2 关键词加入了 as with 
		30.2.3 print 改为函数 print() ,功能更加强大
		30.2.4 改变顺序操作符的行为 x<y 当x,y 类型不一致会抛出 typeError异常,而不是之前的bool类型
		30.2.5 输入函数 由 raw_input 改为 input
		30.2.6 去除元组参数解包  def (a,(b,c)) 不能再使用
	30.3 编码:Python3 源文件默认使用 utf8 编码格式

	
	
二.数据库
	
1.数据库事务?
	单个逻辑工作单元执行的一系列操作,要么完全的执行,要么完全的不执行
	
2.数据库索引?
	2.1 常用索引数据结构类型:
		2.1.1 B-Tree索引,最常用于索引的数据结构
			特点:插入,删除,查找都比较快,另外,B-Tree数据结构是有序的
		2.1.2 哈希索引,使用哈希表作为索引
			特点:查找键值对时十分迅速 诸如 where name="Join" ,数据无序
	2.2 索引类型:
		普通索引,唯一索引,主键索引,唯一索引
	2.3 索引优缺点:
		2.3.1 优点:提高数据里检索速度.包括关联关系查询速度
		2.3.2 缺点:数据量大时,维护时间也相应增加;内存开销增大
	
3. Redis原理?
	3.1.Redis支持的 value 类型很多,例如 String,list,set以及odered_set(有序列表);
	3.2.这些数据类型都支持 pop,push,add/remove操作,而且这些操作都具有原子性
	3.3 为了保证效率,数据存储在内存中;
	3.4 Redis会周期性的将数据写进磁盘,或者把 修改操作 写进追加的记录文件,并在此基础上实现了 主从同步(master-slave)

4.乐观锁和悲观锁?
	4.1悲观锁:假定会发生冲突,屏蔽一切可能会对数据完整性造成影响的操作
	4.2 乐观锁:假定不会发生冲突,只在数据提交时才去检验是否违反数据完整性
	4.3 乐观锁是用来冲突检测的,而悲观锁是冲突避免的
	Tips:高并发解决方案:
		1)创造出隔离区域,尽量让程序在隔离区域运行,减少考虑代码并发的频率;
		2)将一些 并发访问的数据 设置为不可变 就不用担心并发问题;
		3)同一时刻只允许一个活动访问数据,其他活动可访问该数据的备份;
		4)应该使用的策略:
			<1>先使用 乐观锁 ,A,B两个活动都得到数据的备份;
			<2>第一个活动完成后可以很容易的提交数据;
			<3>第二个活动提交时 使用悲观锁 ,如果A活动在提交,B活动就不能提交,等A提交完毕,由B来解决冲突并决定是否提交

5.MVCC?
	多版本并发控制机制;
	通常InnoDB,Falcon和MVCC配合使用;
	InnoDB的MVCC通常会在每行记录后面添加两个列,分别是 事务 开始的时间和事务结束的时间,并非是真实的时间值,而是类似于事务ID的东西.

6.MyISAM和InnoDB?
	6.1 Mysql默认使用MyISAM;
	6.2 MyISAM不支持事务而InnoDB支持,InnoDB默认每条语句都自动commit,建议吧多条sql统一放在begin和commit之间以提高速度;
	6.3 InnoDb支持数据行锁定,MyISAM只能全表锁定;
	6.4 InnoDB支持外键而MyISAM不支持外键;
	6.5 InnoDB支持的外检范围更大,约是MyISAM的两倍;
	6.6 InnoDB不支持全文索引,而MyISAM支持;
	6.7 MyISAM支持GIS数据,InnoDB不支持;
	6.8 没有where 的 count(*) 计数,MyISAM要快的多,MyISAM内部有计数器

三.网络
	
1.TCP协议三次握手过程?
	建立连接需要三次握手:
	1.1 客户端通过向服务器发送一个SYN(synchronous)来创建一个主动打开,作为三次握手的一部分.客户端把这段连接的序号设为随机数A;
	1.2 服务端为合法的SYN请求返回一个SYN/ACK(acknowledgement),ACK的确认码应该是 A+1,同时SYN/ACK包又有一个随机编号 B ;
	1.3 最后,客户端再发送一个ACK,服务端接收到ACK就完成了三次握手,并进入创建连接的状态.此时 包序号被设定为 A+1 ,而相应响应码为 B+1

2.四次挥手?
	断开连接需要四次挥手: 客户端和服务端都有可能首先请求断开连接
	2.1 A端向B端发送 FIN(finish) 标记的报文段;
	2.2 B端接收到之后,不会马上发送状态报文,只是向A端发送 确认序号 ACK,表示还有数据没有传完;
	2.3 B端数据处理完毕,向A端发送 FIN;
	2.4 A端接收到之后FIN之后,向B端发送ACK确认序号,此时等待 2个 MSL时长之后断开连接.(MSL:Maximum Segment Lifetime 最大报文生存时间)

3.ARP协议?
	ARP:Address Resolution Protocol 地址解析协议,根据Ip地址获取物理地址的 TCP/Ip协议
	
4.urllib和urllib2的区别?
	4.1 urllib 提供了urlencode方法来get查询字符串的方法,urllib2没有,这就是它们通常一块儿使用的原因
	4.2 urllib2 允许接受一个Request实例来设置Headers参数,urllib仅可以接受url.这就为什么urllib不能使用User Agent的原因

5.Post和Get区别?
	5.1、GET是从服务器上获取数据，POST是向服务器传送数据。
　　5.2、在客户端， GET方式在通过URL提交数据，数据在URL中可以看到；POST方式，数据放置在HTML HEADER内提交
　　5.3、对于GET方式，服务器端用Request.QueryString获取变量的值，对于POST方式，服务器端用Request.Form获取提交的数据。
	5.4、GET方式提交的数据最多只能有1024字节，而POST则没有此限制(一般是浏览器限制 2 k,协议本身没有限制)
　　5.5、安全性问题。正如在（2）中提到，使用 GET 的时候，参数会显示在地址栏上，而 POST 不会。所以，如果这些数据是中文数据而且是非敏感数据，那么使用 GET ；如果用户输入的数据不是中文字符而且包含敏感数据，那么还是使用POST为好

6.Cookie和Session?
				Cookie	Session
	储存位置	客户端	服务器端
	目的		跟踪会话，也可以保存用户偏好设置或者保存用户名密码等	跟踪会话	
	安全性		不安全	安全
	session技术是要使用到cookie的，之所以出现session技术，主要是为了安全。	
	
7.apache和nginx的区别?	
	7.1 Ngix相比Apach有点:
		7.1.1.轻量级,占用资源少
		7.1.2.抗并发,使用异步处理客户端请求,而Apache是阻塞型,在高并发情况下 Nginx 能保持低消耗高性能
		7.1.3.配制简单
		7.1.4 高度模块化
		7.1.5 社区活跃
	7.2 Apache 优点:
		7.2.1 rewrite 功能更强大
		7.2.2 模块多
		7.2.3 bug 运行稳定

8.HTTP和HTTPS?
	HTTPS使用SSL加密,更加安全;
	两者使用完全不同的连接方式,HTTP默认端口是80,Https是443

9.Idempotence 幂等性
	Get,Put,Delete 都具有幂等性,而Post不是

10.RESTful架构(SOAP,RPC)?
	Rest架构只允许 Get,Post,Put,Delete四中请求方式,具体实现参考项目

11.SOAP?
	SOAP（原为Simple Object Access Protocol的首字母缩写，即简单对象访问协议）是交换数据的一种协议规范，使用在计算机网络Web服务（web service）中，交换带结构信息。SOAP为了简化网页服务器（Web Server）从XML数据库中提取数据时，节省去格式化页面时间，以及不同应用程序之间按照HTTP通信协议，遵从XML格式执行资料互换，使其抽象于语言实现、平台和硬件。

12.RPC?
	PC（Remote Procedure Call Protocol）——远程过程调用协议，它是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。RPC协议假定某些传输协议的存在，如TCP或UDP，为通信程序之间携带信息数据。在OSI网络通信模型中，RPC跨越了传输层和应用层。RPC使得开发包括网络分布式多程序在内的应用程序更加容易。

	总结:服务提供的两大流派.传统意义以方法调用为导向通称RPC。为了企业SOA,若干厂商联合推出webservice,制定了wsdl接口定义,传输soap.当互联网时代,臃肿SOA被简化为http+xml/json.但是简化出现各种混乱。以资源为导向,任何操作无非是对资源的增删改查，于是统一的REST出现了.

	进化的顺序: RPC -> SOAP -> RESTful

13.CGI和WSGI?
	13.1 CGI:
		是通用网关接口,是连接web服务器和应用程序的接口,用户通过CGI来获取动态数据或文件等;
		CGI是独立的程序,可以使用各种语言来编写
	13.2 WSGI:
		Web Serevice Gateway Interface,是Python应用程序或框架与web服务器之间的一个接口,目的是让用户使用可以用统一的语言(Python)来编写前后端程序
		
14.中间人攻击?
	man-in-the-middle-attack 是指攻击者分别于通信的两端建立独立的通信,并交换双方数据,双方认为两者之间是私密的直接的联系,其实数据被中间攻击者完全控制
	
15.c10k问题?
	网络服务器同时支持成千上万的客户端,导致性能下降 成为C10K 问题 ,使用epoll解决(细节不甚清楚)
	
16.socket流程?
	见demo

17.浏览器缓存?
	简单的讲,浏览器将服务器发送的web资源(html页面,图片,js文件等)拷贝一个副本保存起来当浏览器再次请求相同额url时,如果服务器没有更新数据则直接展现缓存的资源.
	缓存加快了响应速度,减少了带宽占用,减少资源消耗
	可以通过添加head 标签来控制缓存
	
18.200 Ok(from cache) 与 304 Not Modified?
	200 ok:没有与服务器确认直接使用缓存
	304 not...:浏览器与服务器确认了一次缓存有效性之后,再用的缓存(一般在刷新页面时)
	
19.Unix 进程间通信方式?
	19.1 管道 pipe(无名管道):
		19.1.1.半双工(数据只能单方向传输),具有固定的读端和写端;
		19.1.2只能在具有亲缘关系的进程间通信(父子,兄弟进程);
		19.1.3可以看做是特殊的文件,具有read/write方法,存在于内存系统中
	19.2 命名管道(FIFO):
		19.2.1 可以在无关的进程间通信;
		19.2.2 FIFO有路径名与之相关联,它以一种特殊的设备文件存在于文件系统中
	19.3 消息队列 (Message Queue):
		19.3.1 消息队列是消息的连接表,存在于内核中,一个消息队列由队列ID来标记;
		19.3.2 消息队列是面向记录的,其中的消息具有特定的格式和优先级;
		19.3.3 消息队列独立于发送与接收进程.当进程终止时,消息内容及队列并不会被清除;
		19.3.4 消息队列可以实现消息的随机查询.不一定按照先进先出的原则进行读取,也可以按照消息类型进行读取
	19.4 信号量(Semaphore)	:
		19.4.1 信号量是一个计数器,用于进程间的同步与互斥,而不是用于进程间数据的存储
		19.4.2 信号量用于进程间同步，若要在进程间传递数据需要结合共享内存;
		19.4.3 信号量基于操作系统的 PV 操作，程序对信号量的操作都是原子操作;
		19.4.4 每次对信号量的 PV 操作不仅限于对信号量值加 1 或减 1，而且可以加减任意正整数;
		19.4.5 支持信号量组
	19.5 共享内存(Shared Memory):
		19.5.1 指两个或多个进程共享一个给定的存储区。
		19.5.2 共享内存是最快的一种 IPC，因为进程是直接对内存进行存取;
		19.5.3 因为多个进程可以同时操作，所以需要进行同步;
		19.5.4 信号量+共享内存通常结合在一起使用，信号量用来同步对共享内存的访问





















	
