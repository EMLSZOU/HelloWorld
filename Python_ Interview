1.python函数传递?
	1)当一个引用传递给函数的时候,函数自动复制一份引用,函数中引用和外部没有没有关系了;
	2)对于可变变量,对该引用的变量进行操作时会改变原来变量的值;而对于不可变的(str,tuple,int等),不会影响外部引用指向的值
	
2.元类?
	1)元类 type 或者继承自type的其他类
	2)元类是用来创造其他类的 MyClass=type('Foo',(),{}),很少用到
	3)Django orm 用元类来实现  参考 models 定义
	
3.实例方法,类方法,静态方法?
	1)实例方法:必须实例化该类才能被调用(Py3不实例化直接用用类调用,会直接返回这个类对象内存地址)
	2)类方法:无需实例化这个类而能被直接调用(也可以被实例调用),可以被子类继承和重写;
		传入的都是类对象,主要用于工厂方法,具体交给子类实现
	3)静态方法:
		无需实例化即可调用,而多个实例对象也可以共用一个静态方法;
		静态方法不能访问类变量和实例变量.

4.Python的自省?
	程序运行时能够知道对象的类型或属性,例如(type,dir,hasAttr,isinstance 等)

5.字典推导式?
	Py2.7时加入
	{key:val for (key,val) in dict.items()}

6.Python中单下划线和双下划线?
	1)单下划线 _func :自定义变量或函数,不能通过 from* import 导入,只能通过类实例来访问;
	2)双下划线 __func:自定义私有属性或函数,即使实例化或子类继承也不能被(直接)访问(解释器会改为_class__func来进行访问,但不同解释器规则可能不一样)
	3)__attr__,两头下划线: Python 内部保留的属性名称易区别于自定义名称,防止冲突
	Tip:Python 中没有 protected 这个说法,要么共有,要么私有
7.HTTP请求过程?
	7.1浏览器向服务器发送HTTP请求:
		7.1.1.包括方法,路径,域名以及其他的Header相关
		7.1.2. 如果是post请求,那么请求还包含一个body,里面是用户提交的数据
	7.2 服务器向浏览器返回HTTP响应:
		7.2.1 Header包括响应代码 200--->OK; 3xx-->重定向; 4xx-->客户端发送的请求错误; 5xx-->服务器端内部处理时发生错误
		7.2.2. 响应类型:由Content-Type决定,即使请求地址中包含1.jpg也未必是图片
		7.2.3. 服务器响应内容会放在Body里面,包含HTML源码;
		7.2.4. 如果浏览器还需要向服务器请求其他资源,图片,视频等,就会重复以上步骤

8.协程?
	8.1 协程是在一个子线程中切换子程序;
	8.2 没有切换线程的开销,效率比较高,不需要多线程的锁机制,只需要判断程序执行的状态即可;
	8.3 对于多核 CPU 可以使用 多线程+协程 来获得很高的效率
	9.4 Python的协程通过 generator 来实现

9.asyncio?
	9.1 asyncio 提供完善的异步 io 支持,通过 yield from 实现
	9.2 协程方法上加注解 @asyncio.coroutine

10.async,await?
	Py 3.5 开始简化 async 的调用,
	10.1 只需要将注解 @asyncio.coroutine 改为 async def foo():
	10.2 将 yield from 改为 await
11.	Python 字符串格式化:%s 和 .format?
	都是占位符,.format更灵活(注意下表越界)
	对于 %s 如果变量值是一个元组,则采用 %(name,)的方式

12.迭代器和生成器?
	12.1 迭代器:每次调用该对象时都会返回自身的下一个元素,
	12.2 生成器: 

13.*args 和 **kwargs?
	13.1 *args 允许传递任意数量的参数  也可以 *mylist 表示传递一个列表
	13.2 **kwargs 允许使用没有事先定义的参数名称  也可以**mydict传递字典类型参数

14.面向切面编程AOP和装饰器?
	14.1 AOP是在程序运行期间,再不修改源代码基础上动态给函数增加功能,通过预编译或运行期动态代理
	14.2 装饰器 Decorator 程序运行期间动态给函数增加功能
	14.3 常用于 日志添加,性能检测等  降低了耦合性和侵入性
	
15.鸭子类型?
	15.1 不关心具体对象类型,只关心行为,只要行为看起来像鸭子就是鸭子类型;
	15.2 比如Python中的 file_like 的对象,比如stringIo,Gzipfile 等有很多相同的方法,都可以当做文件类型使用;
	15.3 再比如只要对象时可迭代的 list,tuple,dict,都可以使用extend方法
	15.4 动态类型语言的而鸭子类型提高了语言的灵活性

16.Python重载?
	16.1 重载的意义,方法参数类型不同,参数个数不同,而且函数功能相同,这种情况下使用重载;
	16.2 Python中,参数类型可变,置于参数个数,可以使用缺省值 因此,Python无需重载

17.新式类和旧式类?
	17.1 Python 2 中默认都是 旧式类(经典类),创建新式类需要显式的继承 Object
	17.2 Py3 默认都是创建新式类
	17.3 新式类  可以使用 __slots__ 函数限制类属性 __class__直接显式本类的类型 增加了__getattrubiute__属性
	17.3 在继承关系搜索时,旧式类深度优先,新式类广度优先(先水平再向上)
	
18. __new__和__init__的区别?
	18.1 __new__ 是一个静态方法,返回一个创建的实例
	19.2 __init__ 初始化方法,什么都不返回

19.super()?
	19.1 super 用来调用当前类父类的初始化方法 :
		class Boo(Aoo):
			super(Aoo,self).__init__()
	19.2 Python的多继承类是通过mro的方式来保证各个父类的函数被逐一调用，而且保证每个父类函数
       只调用一次（如果每个类都使用super）
	   
20.单例模式?集中常用的方法?
	20.1 使用 __new__ 来创建单例,将类的实例在初始化的时候绑定到类的属性 _instance 上面,之后初始化时返回 最后一次 初始化的实例
		class Singleton(object):
			def __new__(cls,*args,**kwargs):
				if not cls.hasattr(cls,"_instance"):
					cls._instance=super(Singleton,cls).__new__(cls)
				return cls._instance
		
		class Aoo(Singleton):
			def __init__(self,name):
				self.name=name
		
		a=Aoo("Bob")
		b=Aoo("Join")
		print (id(a),a.name) # 111 Join
		print(id(b),b.name)  # 111 join
		所有实例的 Id 相同
	20.2 将所有实例的字典绑定为一个 __dict__
		20.2.1在父类中 定义一个字典 _shared_dict
			obj=super(Singleton,cls).__new__(cls)
			obj.__dict__= cls._shared_dict
			return obj
		这样实例化出的子类 id 是不一致的;
		20.2.2 如果想使子类在作为key时 key是一个 例如 dict1[Aoo] 和 dict2[Boo] 是一个key,在父类中重写__hash__ 和 _-eq__方法:
			def __hsh__(self):
				return 1
			def __eq__(self,other):
				try:
					return self.__dict__==other.__dict__
				except:
					return False
	20.3 最简单的方法:将名字绑定到实例上 即 singleton=singleton() 则singleton就是它自己类的唯一对象 
			
21.Python作用域?
	Python 变量查找的范围:
		本地作用域--->当前作用域被嵌入的本地作用域（Enclosing locals）--->全局/模块作用域(global)--->内置作用域(built_in) 

22.GIL线程全局锁?
	22.1 Python 为了保证线程安全采取的独立线程运行机制,即 一个cpu核心只能在同一时间运行一个线程
	22.2 GIL 锁 只是 Cpython 解释器特有,并非 Python 语言本身的机制,Jpython 就没有GIL锁

23.多线程与多进程选择?
	23.1 单核Cpu 多线程:
		23.1.1 IO 密集型 使用多线程 因为进程开销巨大,多进程切换速度不如多线程
		23.1.2 计算密集型  依然使用多线程 原因同上
	23.2 多核 CPU
		23.2.1 IO 密集型 再多的核心也解决不了IO问题  使用多线程
		23.2.2 计算密集型  Python中同一进程下只有一个线程同时运行,使用多线程

23.闭包?	
	23.1 函数中又定义了一个函数,内部函数被当做外部函数的返回值返回,并且外部函数的参数和局部变量被保留在内部函数中,这种程序结构成为闭包;
	23.2.外部函数的返回值也是一个函数,只有当该函数被调用时才会真正执行程序
	23.3 内部函数不能引用外部函数的循环变量,原因同上
	23.4 闭包提高了方法的复用
	
24.lambda?
	lambda 定义了一个匿名函数,并不能提高执行效率,只是让代码看起来更加简洁
	表达式中不要包含 循环 如果能使用 for in 就不要使用 lambda
	
25.函数式编程?
	函数式编程可以归为面向过程的编程方式;
	特点:允许一个函数接收另一个函数作为参数,允许返回值也是一个函数
	三个常用方法: map reduce filter

26.Python里的拷贝?
	26.1 浅拷贝 shallow copy 复制了一个对象,但对于对象中的元素,依然使用引用
	26.2 深拷贝 deep copy 复制一个容器对象,以及容器中的子元素,属于完全复制

27.Python垃圾回收机制?
	主要使用引用计数来跟踪和回收垃圾,在 引用计数 的基础上,采用 标记--清除 来解决容器对象可能产生的循环引用的问题,通过分代回收以空间换时间的方式换取垃圾回收效率
	27.1 引用计数:
		对对象的引用进行计数
	27.2 标记--清除:
		按需分配,当内存不足时,将内存中所有可以访问到的对象打上标记,然后进行清除
	27.3 分代回收:
		将内存块按存活时间分为不同的集合,称为代.根据存活时间不同进行分代回收
	
28.Python is 和 ==	?
	is 判断内存地址,是不是同一个对象或类型
	== 只判断值

29.read,readline和readlines?
	read 读取整个文件
	redline 读取下一行,使用生成器方法
	readlines 读取整个文件到一个迭代器以供我们遍历























	
