1.python函数传递?
	1)当一个引用传递给函数的时候,函数自动复制一份引用,函数中引用和外部没有没有关系了;
	2)对于可变变量,对该引用的变量进行操作时会改变原来变量的值;而对于不可变的(str,tuple,int等),不会影响外部引用指向的值
	
2.元类?
	1)元类 type 或者继承自type的其他类
	2)元类是用来创造其他类的 MyClass=type('Foo',(),{}),很少用到
	3)Django orm 用元类来实现  参考 models 定义
	
3.实例方法,类方法,静态方法?
	1)实例方法:必须实例化该类才能被调用(Py3不实例化直接用用类调用,会直接返回这个类对象内存地址)
	2)类方法:无需实例化这个类而能被直接调用(也可以被实例调用),可以被子类继承和重写;
		传入的都是类对象,主要用于工厂方法,具体交给子类实现
	3)静态方法:
		无需实例化即可调用,而多个实例对象也可以共用一个静态方法;
		静态方法不能访问类变量和实例变量.

4.Python的自省?
	程序运行时能够知道对象的类型或属性,例如(type,dir,hasAttr,isinstance 等)

5.字典推导式?
	Py2.7时加入
	{key:val for (key,val) in dict.items()}

6.Python中单下划线和双下划线?
	1)单下划线 _func :自定义变量或函数,不能通过 from* import 导入,只能通过类实例来访问;
	2)双下划线 __func:自定义私有属性或函数,即使实例化或子类继承也不能被(直接)访问(解释器会改为_class__func来进行访问,但不同解释器规则可能不一样)
	3)__attr__,两头下划线: Python 内部保留的属性名称易区别于自定义名称,防止冲突
	Tip:Python 中没有 protected 这个说法,要么共有,要么私有
7.HTTP请求过程?
	7.1浏览器向服务器发送HTTP请求:
		7.1.1.包括方法,路径,域名以及其他的Header相关
		7.1.2. 如果是post请求,那么请求还包含一个body,里面是用户提交的数据
	7.2 服务器向浏览器返回HTTP响应:
		7.2.1 Header包括响应代码 200--->OK; 3xx-->重定向; 4xx-->客户端发送的请求错误; 5xx-->服务器端内部处理时发生错误
		7.2.2. 响应类型:由Content-Type决定,即使请求地址中包含1.jpg也未必是图片
		7.2.3. 服务器响应内容会放在Body里面,包含HTML源码;
		7.2.4. 如果浏览器还需要向服务器请求其他资源,图片,视频等,就会重复以上步骤

8.协程?
	8.1 协程是在一个子线程中切换子程序;
	8.2 没有切换线程的开销,效率比较高,不需要多线程的锁机制,只需要判断程序执行的状态即可;
	8.3 对于多核 CPU 可以使用 多线程+协程 来获得很高的效率
	9.4 Python的协程通过 generator 来实现

9.asyncio?
	9.1 asyncio 提供完善的异步 io 支持,通过 yield from 实现
	9.2 协程方法上加注解 @asyncio.coroutine

10.async,await?
	Py 3.5 开始简化 async 的调用,
	10.1 只需要将注解 @asyncio.coroutine 改为 async def foo():
	10.2 将 yield from 改为 await
11.	Python 字符串格式化:%s 和 .format?
	都是占位符,.format更灵活(注意下表越界)
	对于 %s 如果变量值是一个元组,则采用 %(name,)的方式

12.迭代器和生成器?
	12.1 迭代器:每次调用该对象时都会返回自身的下一个元素,
	12.2 生成器: 

13.*args 和 **kwargs?
	13.1 *args 允许传递任意数量的参数  也可以 *mylist 表示传递一个列表
	13.2 **kwargs 允许使用没有事先定义的参数名称  也可以**mydict传递字典类型参数

14.面向切面编程AOP和装饰器?
	14.1 AOP是在程序运行期间,再不修改源代码基础上动态给函数增加功能,通过预编译或运行期动态代理
	14.2 装饰器 Decorator 程序运行期间动态给函数增加功能
	14.3 常用于 日志添加,性能检测等  降低了耦合性和侵入性
	
15.鸭子类型?
	15.1 不关心具体对象类型,只关心行为,只要行为看起来像鸭子就是鸭子类型;
	15.2 比如Python中的 file_like 的对象,比如stringIo,Gzipfile 等有很多相同的方法,都可以当做文件类型使用;
	15.3 再比如只要对象时可迭代的 list,tuple,dict,都可以使用extend方法
	15.4 动态类型语言的而鸭子类型提高了语言的灵活性

16.Python重载?
	16.1 重载的意义,方法参数类型不同,参数个数不同,而且函数功能相同,这种情况下使用重载;
	16.2 Python中,参数类型可变,置于参数个数,可以使用缺省值 因此,Python无需重载

17.新式类和旧式类?
	17.1 Python 2 中默认都是 旧式类(经典类),创建新式类需要显式的继承 Object
	17.2 Py3 默认都是创建新式类
	17.3 新式类  可以使用 __slots__ 函数限制类属性 __class__直接显式本类的类型 增加了__getattrubiute__属性
	17.3 在继承关系搜索时,旧式类深度优先,新式类广度优先(先水平再向上)
	
18. __new__和__init__的区别?
	18.1 __new__ 是一个静态方法,返回一个创建的实例
	19.2 __init__ 初始化方法,什么都不返回

19.super()?
	19.1 super 用来调用当前类父类的初始化方法 :
		class Boo(Aoo):
			super(Aoo,self).__init__()
	19.2 Python的多继承类是通过mro的方式来保证各个父类的函数被逐一调用，而且保证每个父类函数
       只调用一次（如果每个类都使用super）
	   
20.单例模式?集中常用的方法?
	20.1 使用 __new__ 来创建单例,将类的实例在初始化的时候绑定到类的属性 _instance 上面,之后初始化时返回 最后一次 初始化的实例
		class Singleton(object):
			def __new__(cls,*args,**kwargs):
				if not cls.hasattr(cls,"_instance"):
					cls._instance=super(Singleton,cls).__new__(cls)
				return cls._instance
		
		class Aoo(Singleton):
			def __init__(self,name):
				self.name=name
		
		a=Aoo("Bob")
		b=Aoo("Join")
		print (id(a),a.name) # 111 Join
		print(id(b),b.name)  # 111 join
		所有实例的 Id 相同
	20.2 将所有实例的字典绑定为一个 __dict__
		20.2.1在父类中 定义一个字典 _shared_dict
			obj=super(Singleton,cls).__new__(cls)
			obj.__dict__= cls._shared_dict
			return obj
		这样实例化出的子类 id 是不一致的;
		20.2.2 如果想使子类在作为key时 key是一个 例如 dict1[Aoo] 和 dict2[Boo] 是一个key,在父类中重写__hash__ 和 _-eq__方法:
			def __hsh__(self):
				return 1
			def __eq__(self,other):
				try:
					return self.__dict__==other.__dict__
				except:
					return False
	20.3 最简单的方法:将名字绑定到实例上 即 singleton=singleton() 则singleton就是它自己类的唯一对象 
			
21.Python作用域?
	Python 变量查找的范围:
		本地作用域--->当前作用域被嵌入的本地作用域（Enclosing locals）--->全局/模块作用域(global)--->内置作用域(built_in) 

22.GIL线程全局锁?
	22.1 Python 为了保证线程安全采取的独立线程运行机制,即 一个cpu核心只能在同一时间运行一个线程
	22.2 GIL 锁 只是 Cpython 解释器特有,并非 Python 语言本身的机制,Jpython 就没有GIL锁

23.多线程与多进程选择?
	23.1 单核Cpu 多线程:
		23.1.1 IO 密集型 使用多线程 因为进程开销巨大,多进程切换速度不如多线程
		23.1.2 计算密集型  依然使用多线程 原因同上
	23.2 多核 CPU
		23.2.1 IO 密集型 再多的核心也解决不了IO问题  使用多线程
		23.2.2 计算密集型  Python中同一进程下只有一个线程同时运行,使用多线程

23.闭包?	
	23.1 函数中又定义了一个函数,内部函数被当做外部函数的返回值返回,并且外部函数的参数和局部变量被保留在内部函数中,这种程序结构成为闭包;
	23.2.外部函数的返回值也是一个函数,只有当该函数被调用时才会真正执行程序
	23.3 内部函数不能引用外部函数的循环变量,原因同上
	23.4 闭包提高了方法的复用
	
24.lambda?
	lambda 定义了一个匿名函数,并不能提高执行效率,只是让代码看起来更加简洁
	表达式中不要包含 循环 如果能使用 for in 就不要使用 lambda
	
25.函数式编程?
	函数式编程可以归为面向过程的编程方式;
	特点:允许一个函数接收另一个函数作为参数,允许返回值也是一个函数
	三个常用方法: map reduce filter

26.Python里的拷贝?
	26.1 浅拷贝 shallow copy 复制了一个对象,但对于对象中的元素,依然使用引用
	26.2 深拷贝 deep copy 复制一个容器对象,以及容器中的子元素,属于完全复制

27.Python垃圾回收机制?
	主要使用引用计数来跟踪和回收垃圾,在 引用计数 的基础上,采用 标记--清除 来解决容器对象可能产生的循环引用的问题,通过分代回收以空间换时间的方式换取垃圾回收效率
	27.1 引用计数:
		对对象的引用进行计数
	27.2 标记--清除:
		按需分配,当内存不足时,将内存中所有可以访问到的对象打上标记,然后进行清除
	27.3 分代回收:
		将内存块按存活时间分为不同的集合,称为代.根据存活时间不同进行分代回收
	
28.Python is 和 ==	?
	is 判断内存地址,是不是同一个对象或类型
	== 只判断值

29.read,readline和readlines?
	read 读取整个文件
	redline 读取下一行,使用生成器方法
	readlines 读取整个文件到一个迭代器以供我们遍历

30.Python 2和3的差别?
	30.1 性能差别:一般来讲,python3 运行速度比 python2 慢
	30.2 语法差别:
		30.2.1 去除了 <> 全部改用 !==;
		30.2.2 关键词加入了 as with 
		30.2.3 print 改为函数 print() ,功能更加强大
		30.2.4 改变顺序操作符的行为 x<y 当x,y 类型不一致会抛出 typeError异常,而不是之前的bool类型
		30.2.5 输入函数 由 raw_input 改为 input
		30.2.6 去除元组参数解包  def (a,(b,c)) 不能再使用
	30.3 编码:Python3 源文件默认使用 utf8 编码格式

	
	
二.数据库
	
1.数据库事务?
	单个逻辑工作单元执行的一系列操作,要么完全的执行,要么完全的不执行
	
2.数据库索引?
	2.1 常用索引数据结构类型:
		2.1.1 B-Tree索引,最常用于索引的数据结构
			特点:插入,删除,查找都比较快,另外,B-Tree数据结构是有序的
		2.1.2 哈希索引,使用哈希表作为索引
			特点:查找键值对时十分迅速 诸如 where name="Join" ,数据无序
	2.2 索引类型:
		普通索引,唯一索引,主键索引,唯一索引
	2.3 索引优缺点:
		2.3.1 优点:提高数据里检索速度.包括关联关系查询速度
		2.3.2 缺点:数据量大时,维护时间也相应增加;内存开销增大
	
3. Redis原理?
	3.1.Redis支持的 value 类型很多,例如 String,list,set以及odered_set(有序列表);
	3.2.这些数据类型都支持 pop,push,add/remove操作,而且这些操作都具有原子性
	3.3 为了保证效率,数据存储在内存中;
	3.4 Redis会周期性的将数据写进磁盘,或者把 修改操作 写进追加的记录文件,并在此基础上实现了 主从同步(master-slave)

4.乐观锁和悲观锁?
	4.1悲观锁:假定会发生冲突,屏蔽一切可能会对数据完整性造成影响的操作
	4.2 乐观锁:假定不会发生冲突,只在数据提交时才去检验是否违反数据完整性
	4.3 乐观锁是用来冲突检测的,而悲观锁是冲突避免的
	Tips:高并发解决方案:
		1)创造出隔离区域,尽量让程序在隔离区域运行,减少考虑代码并发的频率;
		2)将一些 并发访问的数据 设置为不可变 就不用担心并发问题;
		3)同一时刻只允许一个活动访问数据,其他活动可访问该数据的备份;
		4)应该使用的策略:
			<1>先使用 乐观锁 ,A,B两个活动都得到数据的备份;
			<2>第一个活动完成后可以很容易的提交数据;
			<3>第二个活动提交时 使用悲观锁 ,如果A活动在提交,B活动就不能提交,等A提交完毕,由B来解决冲突并决定是否提交

5.MVCC?
	多版本并发控制机制;
	通常InnoDB,Falcon和MVCC配合使用;
	InnoDB的MVCC通常会在每行记录后面添加两个列,分别是 事务 开始的时间和事务结束的时间,并非是真实的时间值,而是类似于事务ID的东西.

6.MyISAM和InnoDB?
	6.1 Mysql默认使用MyISAM;
	6.2 MyISAM不支持事务而InnoDB支持,InnoDB默认每条语句都自动commit,建议吧多条sql统一放在begin和commit之间以提高速度;
	6.3 InnoDb支持数据行锁定,MyISAM只能全表锁定;
	6.4 InnoDB支持外键而MyISAM不支持外键;
	6.5 InnoDB支持的外检范围更大,约是MyISAM的两倍;
	6.6 InnoDB不支持全文索引,而MyISAM支持;
	6.7 MyISAM支持GIS数据,InnoDB不支持;
	6.8 没有where 的 count(*) 计数,MyISAM要快的多,MyISAM内部有计数器
7.存储过程和触发器?
	7.1存储过程:
		7.1.1存储过程就是sql语句和控制语句的集合,就像是存在于数据库中的方法 
		7.1.2存储过程的作用:
			7.1.2.1 防止sql注入
			7.1.2.2 执行速度更快
			7.1.2.3 减少网络流量
			7.1.2.4 模块化程序设计(类似于方法的复用)
	7.2触发器:
		7.2.1 触发器就是一种特殊类型的存储过程,当操作了一张表时希望同时触发一些行为和操作.
		7.2.2 自动化操作 可以指定 insert update delete

三.网络
	
1.TCP协议三次握手过程?
	建立连接需要三次握手:
	1.1 客户端通过向服务器发送一个SYN(synchronous)来创建一个主动打开,作为三次握手的一部分.客户端把这段连接的序号设为随机数A;
	1.2 服务端为合法的SYN请求返回一个SYN/ACK(acknowledgement),ACK的确认码应该是 A+1,同时SYN/ACK包又有一个随机编号 B ;
	1.3 最后,客户端再发送一个ACK,服务端接收到ACK就完成了三次握手,并进入创建连接的状态.此时 包序号被设定为 A+1 ,而相应响应码为 B+1

2.四次挥手?
	断开连接需要四次挥手: 客户端和服务端都有可能首先请求断开连接
	2.1 A端向B端发送 FIN(finish) 标记的报文段;
	2.2 B端接收到之后,不会马上发送状态报文,只是向A端发送 确认序号 ACK,表示还有数据没有传完;
	2.3 B端数据处理完毕,向A端发送 FIN;
	2.4 A端接收到之后FIN之后,向B端发送ACK确认序号,此时等待 2个 MSL时长之后断开连接.(MSL:Maximum Segment Lifetime 最大报文生存时间)

3.ARP协议?
	ARP:Address Resolution Protocol 地址解析协议,根据Ip地址获取物理地址的 TCP/Ip协议
	
4.urllib和urllib2的区别?
	4.1 urllib 提供了urlencode方法来get查询字符串的方法,urllib2没有,这就是它们通常一块儿使用的原因
	4.2 urllib2 允许接受一个Request实例来设置Headers参数,urllib仅可以接受url.这就为什么urllib不能使用User Agent的原因

5.Post和Get区别?
	5.1、GET是从服务器上获取数据，POST是向服务器传送数据。
　　5.2、在客户端， GET方式在通过URL提交数据，数据在URL中可以看到；POST方式，数据放置在HTML HEADER内提交
　　5.3、对于GET方式，服务器端用Request.QueryString获取变量的值，对于POST方式，服务器端用Request.Form获取提交的数据。
	5.4、GET方式提交的数据最多只能有1024字节，而POST则没有此限制(一般是浏览器限制 2 k,协议本身没有限制)
　　5.5、安全性问题。正如在（2）中提到，使用 GET 的时候，参数会显示在地址栏上，而 POST 不会。所以，如果这些数据是中文数据而且是非敏感数据，那么使用 GET ；如果用户输入的数据不是中文字符而且包含敏感数据，那么还是使用POST为好

6.Cookie和Session?
				Cookie	Session
	储存位置	客户端	服务器端
	目的		跟踪会话，也可以保存用户偏好设置或者保存用户名密码等	跟踪会话	
	安全性		不安全	安全
	session技术是要使用到cookie的，之所以出现session技术，主要是为了安全。	
	
7.apache和nginx的区别?	
	7.1 Ngix相比Apach有点:
		7.1.1.轻量级,占用资源少
		7.1.2.抗并发,使用异步处理客户端请求,而Apache是阻塞型,在高并发情况下 Nginx 能保持低消耗高性能
		7.1.3.配制简单
		7.1.4 高度模块化
		7.1.5 社区活跃
	7.2 Apache 优点:
		7.2.1 rewrite 功能更强大
		7.2.2 模块多
		7.2.3 bug 运行稳定

8.HTTP和HTTPS?
	HTTPS使用SSL加密,更加安全;
	两者使用完全不同的连接方式,HTTP默认端口是80,Https是443

9.Idempotence 幂等性
	Get,Put,Delete 都具有幂等性,而Post不是

10.RESTful架构(SOAP,RPC)?
	Rest架构只允许 Get,Post,Put,Delete四中请求方式,具体实现参考项目

11.SOAP?
	SOAP（原为Simple Object Access Protocol的首字母缩写，即简单对象访问协议）是交换数据的一种协议规范，使用在计算机网络Web服务（web service）中，交换带结构信息。SOAP为了简化网页服务器（Web Server）从XML数据库中提取数据时，节省去格式化页面时间，以及不同应用程序之间按照HTTP通信协议，遵从XML格式执行资料互换，使其抽象于语言实现、平台和硬件。

12.RPC?
	PC（Remote Procedure Call Protocol）——远程过程调用协议，它是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。RPC协议假定某些传输协议的存在，如TCP或UDP，为通信程序之间携带信息数据。在OSI网络通信模型中，RPC跨越了传输层和应用层。RPC使得开发包括网络分布式多程序在内的应用程序更加容易。

	总结:服务提供的两大流派.传统意义以方法调用为导向通称RPC。为了企业SOA,若干厂商联合推出webservice,制定了wsdl接口定义,传输soap.当互联网时代,臃肿SOA被简化为http+xml/json.但是简化出现各种混乱。以资源为导向,任何操作无非是对资源的增删改查，于是统一的REST出现了.

	进化的顺序: RPC -> SOAP -> RESTful

13.CGI和WSGI?
	13.1 CGI:
		是通用网关接口,是连接web服务器和应用程序的接口,用户通过CGI来获取动态数据或文件等;
		CGI是独立的程序,可以使用各种语言来编写
	13.2 WSGI:
		Web Serevice Gateway Interface,是Python应用程序或框架与web服务器之间的一个接口,目的是让用户使用可以用统一的语言(Python)来编写前后端程序
		
14.中间人攻击?
	man-in-the-middle-attack 是指攻击者分别于通信的两端建立独立的通信,并交换双方数据,双方认为两者之间是私密的直接的联系,其实数据被中间攻击者完全控制
	
15.c10k问题?
	网络服务器同时支持成千上万的客户端,导致性能下降 成为C10K 问题 ,使用epoll解决(细节不甚清楚)
	
16.socket流程?
	见demo

17.浏览器缓存?
	简单的讲,浏览器将服务器发送的web资源(html页面,图片,js文件等)拷贝一个副本保存起来当浏览器再次请求相同额url时,如果服务器没有更新数据则直接展现缓存的资源.
	缓存加快了响应速度,减少了带宽占用,减少资源消耗
	可以通过添加head 标签来控制缓存
	
18.200 Ok(from cache) 与 304 Not Modified?
	200 ok:没有与服务器确认直接使用缓存
	304 not...:浏览器与服务器确认了一次缓存有效性之后,再用的缓存(一般在刷新页面时)
	
19.Unix 进程间通信方式?
	19.1 管道 pipe(无名管道):
		19.1.1.半双工(数据只能单方向传输),具有固定的读端和写端;
		19.1.2只能在具有亲缘关系的进程间通信(父子,兄弟进程);
		19.1.3可以看做是特殊的文件,具有read/write方法,存在于内存系统中
	19.2 命名管道(FIFO):
		19.2.1 可以在无关的进程间通信;
		19.2.2 FIFO有路径名与之相关联,它以一种特殊的设备文件存在于文件系统中
	19.3 消息队列 (Message Queue):
		19.3.1 消息队列是消息的连接表,存在于内核中,一个消息队列由队列ID来标记;
		19.3.2 消息队列是面向记录的,其中的消息具有特定的格式和优先级;
		19.3.3 消息队列独立于发送与接收进程.当进程终止时,消息内容及队列并不会被清除;
		19.3.4 消息队列可以实现消息的随机查询.不一定按照先进先出的原则进行读取,也可以按照消息类型进行读取
	19.4 信号量(Semaphore)	:
		19.4.1 信号量是一个计数器,用于进程间的同步与互斥,而不是用于进程间数据的存储
		19.4.2 信号量用于进程间同步，若要在进程间传递数据需要结合共享内存;
		19.4.3 信号量基于操作系统的 PV 操作，程序对信号量的操作都是原子操作;
		19.4.4 每次对信号量的 PV 操作不仅限于对信号量值加 1 或减 1，而且可以加减任意正整数;
		19.4.5 支持信号量组
	19.5 共享内存(Shared Memory):
		19.5.1 指两个或多个进程共享一个给定的存储区。
		19.5.2 共享内存是最快的一种 IPC，因为进程是直接对内存进行存取;
		19.5.3 因为多个进程可以同时操作，所以需要进行同步;
		19.5.4 信号量+共享内存通常结合在一起使用，信号量用来同步对共享内存的访问


内存泄漏:
程序对内存失去了控制已经不使用的内存无法释放造成浪费 程序卡死
一般由对象循环引用引起的
调优手段:
1.手动垃圾回收()
2.调高垃圾回收阈值
3.避免循环引用
函数参数传递:
	可变参数是引用传递
	不可变参数是值传递
map&reduce
	map:逐个作用到每个元素,互不影响
	reduce:逐个作用到每个元素,结果累加
回调函数的通信:
	把一个函数的指针(地址)作为参数传递给另一个函数,将整个函数作为一个对象传递给被作用的函数
lambda表达式"
	匿名函数,一般给filter,map函数服务
	作为回调函数传递某些参数
单例模式:
	class Aoo(object):
		__instance=None
		def __new__(cls,*args,**kwargs):
			if cls.__instance is None:
				cls.__instance=object.__new__(cls)
				return cls.__instance
			else:
				return cls.__instance
	单例用在应用配置,日志类,数据库连接池,多线程池等需要资源共享和控制的地方
工厂模式
装饰器:
	在函数运行期间,动态增加函数功能的方法
	可以进行增加日志打印,性能测试,事务处理等
python中is 和 ==:
	python中 is 判断两个对象是否是一个对象
	== 则判断两个值是否相等
面向过程:
	基于功能分析的,以算法为中心的程序设计方法
面向对象:
	基于结构分析的,以数据为中心的程序设计方法
match&search
	match 从开始检测匹配
	search 查找整个目标字符串
进程:
	一个运行的程序就是一个进程,没有运行的代码叫做程序.进程是系统资源分配的最小单位,有自己独立	的内存空间,进程间数据不共享,内存开销大
线程:
	调度执行的最小单位,也叫执行路径.不能独立存在,必须依赖进程,一个进程至少拥有一个线程(主线程),	多个线程共享内存.
协程:
	协会是一种线程的子程序(更轻量级的线程),拥有独立的寄存器和栈.携程切换时效率极高,可以不加锁的访问全局变量
多线程竞争:
	统一进程下的线程争抢资源
锁:
	Python提供的对线程控制的对象.有互斥锁,可充入锁和死锁
可重入锁:
	threading.Rlock
	包含一个lock和counter(计数器),counter记录了线程获得锁的次数,只有当所有次数都被释放	(release)后,其他线程才能获得锁
同步:
	任务按顺序执行,上个执行完开始下一个
异步:
	任务并发同时执行,必要时,一个任务可以获取另一个任务的结果即回调
阻塞:
	被调用程序执行时卡住了调用者,即为阻塞
非阻塞:
	被调用程序执行时不会卡住调用者,即为非阻塞
孤儿进程:
	父进程退出而子进程还在运行的,该子进程就是孤儿进程
僵尸进程:
	进程使用fork创建子进程,子进程退出而父进程没有调用wait函数去获取子进程信息,从而导致子进程	描述信息依然保留在系统中,该子进程称为僵尸进程
	如何避免?
	1)父进程调用wait()函数
	2)fork两次,使用孙子进程去执行任务
多线程VS多进程
	1)计算密集型用多进程,IO密集型用多线程
	2)进程是并行,线程是并发
	3)并行,同一时刻多个任务同时运行;并发:同一时间间隔内,多任务交替执行
Socket连接强行关闭:
	在socket连接中,循环检测一个开关标记变量,如果变量为关闭,则调用close方法
TCP&UDP:
	UDP是面向无连接的通讯协议,UDP数据包括目标端口号和源端口号信息.
	优点:UDP速度快,操作简单,占用资源少,通讯不需要连接,可以实现广播发送
	缺点:由于时无连接通讯,不保证数据按时,正确送达,失败后也不会重新发送,不可靠
	
	TCP是面向有连接的通讯协议,三次握手建立连接,四次挥手断开连接
	优点:有链接,保证数据正确按顺序送达.
	缺点:相对UDP,速度慢,占用系统资源比较多
浏览器通过WSGI请求动态资源的过程:
	1)浏览器发送动态资源请求给Web服务器
	2)web服务器收到请求后发送一个属性给对应应用程序框架
	3)应用程序框架通过WSGI引用web服务器的方法,设置返回的状态和头信息
	4)调用后返回,此时web服务器保存了刚刚设置的信息
	5)应用程序查询数据库,生成动态页面的body信息,并返回给web服务器
	6)web服务器把数据返回给浏览器
浏览器访问www.xxx.com的过程:
	1)解析IP
	2)与目标服务器建立连接,TCP 三次握手,发送请求数据
	3)服务器查询自己的服务得到相应的结果,返回给浏览器
	4)浏览器渲染页面
	5)浏览器关闭TCP连接,通过4次挥手
HTTP状态码作用&常见状态码意思:
	通过状态码告诉客户端服务器执行状态,以判断下一步的操作
	100~199:服务器收到部分请求,要求客户端继续提供剩余数据
	200~299:服务器已成功接收请求并完成处理,常见200
	300~399:为完成请求,服务器需要进一步细化请求.302,转发;304,307使用缓存资源
	400~499:客户端请求错误. 404,请求的页面不存在,403服务器拒绝访问,权限不够
	500~599:服务器出现错误,一般为服务器程序一场.500
TCP连接 三次握手&四次挥手:
	三次握手:
	1)客户端向服务器发送一个带有SYN标志,以及随机生成的序号(eg:100)的报文
	2)服务端收到请求后,向客户端返回一个带有SYN标志,以及随机生成的序号(eg:200)和ACK确认码	100+1的报文
	30)收到服务端的确认消息后,客户端再次发送一个缺人码,此时报文序号为200+1
	四次挥手:
	由于TCP连接是可以双向通信的(也就是全双工),因此两个方向都必须单独进行关闭
	1)客户端发送带有fin标识的请求到服务端,请求关闭连接;
	2)服务端数据发送完成后,发送ACK答应关闭连接;
	3)服务端也向客户端发送带有fin标志的消息,请求关闭
	4)客户端回应ACK消息给服务端,答应关闭
TCP的2MSL:
	主动发送fin关闭的一方,在四次挥手的最后一次会等待一短时间,我们称这段时间为2MSL
	TIME_WAIT状态存在的两个理由:
	1)让四次挥手关闭的流程更加可靠
	客户端发送最后一次ACK后,等待2MSL时长,保证服务器能收到ACk消息
	2)防止丢包后,对后续新建连接的数据传输造成影响
	保证上一个连接关闭,从网络中删除,不会对新连接产生影响
HTTP&HTTPS:
	1)HTTP协议是超文本传输协议,基于TCP/IP协议,浏览器通过HTTP协议向服务器发送请求,并接收返回信息;属于应用层面向对象的协议
	2)HTTPS协议是HTTP+SSL加密传输,HTTP则是明文传输,https更安全
	3)HTTP请求方法:
		<1>GET 请求指定页面,返回实体主体
		<2>HEAD 同GET,没有消息体,用于获取报头
		<3>POST 向指定资源提交数据进行处理请求(表单),请求体包含数据.会导致新的资源的建立或原		有资源的修改
		<4>PUT 从客户端向服务器传送的数据取代指定文档的内容
		<5>delete 删除指定的额资源
		<6>connect
		<7>Option 允许客户端查看服务器的性能
		<8>TRACE 回显服务器收到的请求,主要用于测试
Socket套接字需要传入哪些参数:
	AddressFamily和Type,分别表示套接字应用场景和类型
	应用场景: AF_UNIX(同一台机器上的进程通信),AF_INET(IPV4协议通信)
	类型:	SOCKET_STREAM流套接字 SOCKET_DDRAM数据报文套接字
七层模型,及各协议所在层级:
	从下到上:
	物理层>>>数据链路层>>>网络层>>>传输层>>>会话层>>>表示层>>>应用层
	IP:网络层
	TCP/UDP:传输层
	HTTP,RTSP,FTP:应用层协议
URL的形式:
	形式:scheme://host:port/path/.../?query-string/#anchor
	scheme:协议 HTTP,HTTPS,FTP
	host:port	 服务器地址+端口号
	path:访问资源的路径
	query-sting: 请求参数
	#anchor:锚(跳转到页面指定的锚点)


CSS:
Css初始化,有什么好处?
	Css初始化是指重设浏览器的样式.不同的浏览器样式也可能不同,不进行初始化会导致页面差异
	好处:能够统一标签在各大浏览器的样式显示,减少css代码
JS:
AJAX是什么,如何使用?

Django:
ORM查询:
	all()查询Model对应表所有信息
	get() 返回表中满足条件的的一条数据,多条数据和无数据都会报错
	filter() 条件查询
		条件格式:
		*模型类属性名*__条件名=值
		1)判等 ObjInfo.object.filter(id=1/id_exact=a) exact精确,可以用模糊
		2)模糊查询 like
		包含 	ObjInfo.objects.filter(name_contains="haha")
		范围  	ObjInfo.objects.filter(id_in=[1,2,3])
		比较   	ObjInfo.objects.filter(id_gtlt/gte=2) 小于或等于
		排除 	ObjInfo.objects.exclude(...)
	F对象:用于类属性之间的比较条件
		from django.db.models import F/Q
		eg: ObjInfo.objects.filter(bread_gt=F('bcomment')*2)
	Q对象: 用于查询时的逻辑条件 能够用 & | ~进行连接
		tips:F,Q只是一种封装
	排序: orderby()  返回queryset
	聚合函数: aggregate  包括sum,count ,avg,max,min  返回 字段_函数:值 eg: {'bread_sum':120}
	分组查询:	annotate  为调用的queryset对象中的每一个对象都生成一个独立的统计值
	一对多: ForeignKey
django消息中间件:
	可自定义中间件,六个方法
	init 	process_request	process_view/template_response/response/exception
	在settings中添加自定义中间件,会自动调用,其中 Request顺序执行,response会反序执行
	可用于拦截请求,异常处理,鉴权等




















	
